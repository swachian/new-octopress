<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: java | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2018-04-28T22:04:44+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effective Java 3rd Edition]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2018/02/20/effective-java-3rd-edition/"/>
    <updated>2018-02-20T23:01:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2018/02/20/effective-java-3rd-edition</id>
    <content type="html"><![CDATA[<p>「Effective Java」第三版在过年期间出版了，对比第二版主要补充了<code>lambda</code>和<code>stream</code>的内容，序列化方面
则希望大家不要再使用java原生的内容，其他变化不大。但是，和第一版比较起来，变化就很大了。除上述内容外，
第二版较第一版增加了<code>autoboxing/autounboxing</code>，<code>enum</code>, <code>annotation</code>,<code>generic programming</code>, 整个的编程建议也从57条增长到78条再到第三版的90条。</p>

<p>借用作者在第三版的前言，在1997年，Java的创始者Gosling描述java是一种“蓝领语言”（blue collar language），意味着当时的java相当简单（pretty simple）。与此同时，C++的创始人Stroustrup则警告所谓java的简单和其他很多新语言一样，只是误解以及功能上的不完善，随着时间的流逝，Java在尺寸和复杂性上都将大规模成长。不得不说，三者都是大师，而Java虽然依旧还是工业级的语言，但复杂度和规模已经较我十几年前初学时多了许多。或许，也因此大学里正在寻求一门其他语言来取代Java的教学地位吧。</p>

<p>此书非常经典，虽然作者说不用从头到尾通读，但是，建议还是全部都读一遍，甚至可能需要反复阅读并加以实践。比如其中的primitives和boxed primitives，即<code>int</code>和<code>Integer</code>，其间的坑在新项目中就踩过，而之前阅读后只是尽量不去用Integer这些boxed的类型，而这个新项目中由于前后交互的需要必须使用了Integer，于是就把<code>==</code>, 内容为<code>null</code>的坑都踩到了。</p>

<p>开卷有益，何况经典！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring cloud 服务治理]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/10/07/spring-cloud-fu-wu-zhi-li/"/>
    <updated>2017-10-07T13:54:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/10/07/spring-cloud-fu-wu-zhi-li</id>
    <content type="html"><![CDATA[<p>服务治理是近年来架构中的热点部分，尽管比照ICE这些内容其实十几年前就已经有了，
只是五六年前伴随着系统越做越庞大，才变得必要起来。</p>

<p>简单理解一下，其主要内容基本是：</p>

<ul>
<li>要有一个服务中心，服务中心最好是集群的</li>
<li>要能向中心注册服务，服务的地址用名称而不是ip硬绑</li>
<li>要能发现一个服务，其实就是用名称通过服务中心找到服务的ip和端口</li>
<li>要一个可以轮流访问服务集群的客户端</li>
<li>此外再配合上消息总线等内容</li>
</ul>


<p>有了这些，基本一个服务治理的框架就基本形成了。</p>

<p>《Spring Cloud 微服务实战》是一本很不错的书，有动手的介绍，有源码的分析，写的也算精炼。</p>

<h3>Eureka 服务治理中心</h3>

<p>启动服务中心后，配置客户端主要包含两部分：</p>

<ul>
<li>服务注册相关信息： 包括服务中心地址、服务获取间隔时间、可用区域，以<code>eureka.client</code>为前缀</li>
<li>服务实例相关的配置信息： 包括实例的名称、IP地址、端口号、健康检查路径等，以<code>eureka.instance</code>为前缀</li>
</ul>


<h3>Ribbon</h3>

<p>Spring Cloud的负载均衡是在客户端实现的。
<code>WeightedResponseTimeRule</code>是个比较复杂的实现。</p>

<h3>Hystrix</h3>

<p>这是一个容错断路器，当出现超时等状况时直接调用指定的回掉函数。使用了RxJava库的异步操作模式，
实现了发送+观察的效果，所以可以中断请求。</p>

<h3>Feign</h3>

<p>在RestTemplate上进一步抽象，实现和Spring MVC对等的method封装。因为要组client，所以<code>@RequestParam</code>
中的value不能少。</p>

<p>```java
@FeignClient("Hello-Service")
public interface HelloService {
  @RequestMapping(value="/hello1", method=RequestMethod.GET) //指明要访问的路径和方法
  User hello(@RequestParam("name") String name, @RequestHeader("age") Integer age); //指明构造请求是的参数名称
}</p>

<p>//调用方式
helloService.hello("DiDi", 30);
```</p>

<h3>Zuul Api 网关</h3>

<p>网关的事情就两条：<br/>
1. 路由
2. 过滤</p>

<p>Zuul的路由结合了治理服务，下面就把一个路径全部转发去了一个服务</p>

<p><code>
zuul.routes.service-a.path=/aaa/**
zuul.routes.service-a.serviceId=Hello-Service
</code>
过滤器则可以通过继承一个抽象类<code>ZuulFilter</code>并实现4个方法来实现。</p>

<p>```java
public class AccessFilter extends ZuulFilter {
  ....
}</p>

<p>@EnableZuulProxy
@SpringCloudApplication
public class Application {
  public static void main(String[] args) {</p>

<pre><code>new SpringApplicationBuilder(Application.class).web(true).run(args);
</code></pre>

<p>  }</p>

<p>  @Bean
  public AccessFilter accessFilter() {</p>

<pre><code>return new AccessFilter();
</code></pre>

<p>  }
}
```</p>

<h3>Spring Cloud Config</h3>

<p>基于git（也可以是svn或本地目录）的配置中心，其实就是一个可以保存各种配置信息，然后由其他微服务读取后拉起应用。</p>

<h3>Bus 和 Stream 消息总线和消息流</h3>

<p>目前只支持RabbitMQ和kafka两种队列，kafka更多的好像和实时日志处理流相关</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java新的兼容性挑战者Kotlin]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/05/21/javaxin-de-jian-rong-xing-tiao-zhan-zhe-kotlin/"/>
    <updated>2017-05-21T16:39:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/05/21/javaxin-de-jian-rong-xing-tiao-zhan-zhe-kotlin</id>
    <content type="html"><![CDATA[<p>520期间被刷屏的除了show 恩爱，就是Kotlin了。
原本只是在一个做安卓的小朋友发的pdf里看见了Kotlin，想想应该又是一个和scala groovy或者closure类似的东西---
可以跑在jvm上，能利用jdk的库，语言表达力又强于java。</p>

<p>Java尽管有点啰嗦，语言表达力确实一般，但企业级的支持很强，jvm的性能更是出色，所以在类库、ide、甚至大型开发框架方面是无与伦比的。在jvm上跑的语言很多，甚至想部分替代的如scala closure groovy等等都火过一阵子，但是java继续维持着自己的优势地位。</p>

<p>然而这次真正被刷屏的，是因为Google认了Kotlin为<strong>干儿子</strong>，甚至以后可能是亲儿子，将kotlin变成了
头等安卓开发语言。查了一下，此前获得此定位的仅有java，这就可能有很大的不同了。kotlin有了google的支持，而其他所谓挑战者可没这个干爹。并且，Kotlin的创建者又是目前最流行的java ide的公司贡献的，可以保证在<strong>开发工具上的体验和支持</strong>，这么看来它的优势就比scala等强多了。</p>

<p>希望还是能帮助java改进吧，当然这个有点难，即使java8好几年下来了，也不知道有没有普及率超过java程序员的50%</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[thymeleaf感想]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/05/21/thymeleafgan-xiang/"/>
    <updated>2017-05-21T00:07:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/05/21/thymeleafgan-xiang</id>
    <content type="html"><![CDATA[<p>刚使用spring boot时得知thymeleaf取代了jsp的默认地位，我是有所抵触的，做法就是重新配置回了jsp。
然而随着java web开发前后端业已分离的现实，逐步明白view层是thymeleaf还是jsp已经不再重要。因为java已变成
服务成守候在服务器侧，而原先页面的工作已经完全交给了（不需要会java）的前端人员，且他们是完全可以胜任的。</p>

<p>实际上截至目前，最新版的thymeleaf已经到了3.0以上的版本，而spring boot最新版集成的还是<strong>2.x</strong>的thymeleaf的版本，
可以认为这块已经处于冷淡的状态。</p>

<p>不过，凡是总有例外。这次又碰见了需要产生静态页面的业务场景，其中有不少的业务逻辑，所以还是需要一个view层，考虑到
新团队的习惯，决定采用thymeleaf吧，这样以后维护可以交给前端来做。于是简易学习了一下leaf，感觉还是不错的。</p>

<p>leaf最大的特色就是前端人员可以直接打开leaf所在的html页面，并做到完全的无异物感。脚本、链接完全动态静态可以分开。
这样解决了jsp长期以来美工介入很困难的问题,同时做的又比freemaker等更加到位。内置标签支持的语言语法也很现代化和好用，一般有jsp经验的程序员，
花个半天看一下一百来页的手册并动手实践一下，就完全可上手了。至于<code>jsp</code>，是可以退出历史舞台了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[zookeeper]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/01/15/zookeeper/"/>
    <updated>2017-01-15T10:27:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/01/15/zookeeper</id>
    <content type="html"><![CDATA[<p>用于协作的服务，提供目录树的结构。基本可以认为是Yahoo出品。</p>

<p>data registers - called znodes, file
parlance - directory</p>

<p>数据全部保存在内存中。</p>

<p>优势：
1. 性能好，可在大规模的分布式系统里使用
2. 可靠性高，可防止单点故障
3. 严格的顺序性，可满足复杂的、高精的客户端同步实现要求</p>

<p>znode的读写有acl控制以及版本号</p>

<p>leader nodes负责接受写的请求，follower nodes负责被同步和读取</p>

<p>配置示例</p>

<p><code>
tickTime=2000
dataDir=/var/lib/zookeeper
clientPort=2181
initLimit=5
syncLimit=2
server.1=zoo1:2888:3888
server.2=zoo2:2888:3888
server.3=zoo3:2888:3888
</code></p>

<p>tickTime是一个即使单元，单位是毫秒，2000表示2秒。<br/>
dataDir是存放数据文件的物理位置。<br/>
initLimit表示n个tickTime，上面这个就是10秒的意思，表示连接上leader nodes需要的时间单元数量。<br/>
syncLimit表示山离皇帝能有多远过期<br/>
server.1中的1的服务器内部的<code>myid</code>，zoo1是服务器地址，第二个port即2888用于follewer连接leader，
第三更port 3888用于选举leader。</p>

<p>基本上，zookeeper可以理解成一个分布式系统里，用于进程间通信的中间件，所以剩下的就是客户端调用了。
项目本身提供了C和Java的binding，具体实现时每个客户端会分为IO线程和watch线程两个。而Netflix在此基础上，
构造了wrapper: <code>curator</code>，以方便开发。</p>

<p>首先，引入maven依赖:</p>

<p>```
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;  
&lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;  
&lt;version&gt;3.2.1&lt;/version&gt;  
</code></pre>

<p></dependency>
```</p>

<p>然后，在代码中可如下调用：</p>

<p>```java
package zookeepertest;</p>

<p>import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;</p>

<p>public class CuratorTest {</p>

<pre><code>public void set() {
    String zookeeperConnectionString="127.0.0.1:2181";
    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
            CuratorFramework client = CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);


            client.start();

            try {
                client.create().forPath("/my", "555".getBytes());

                client.getData().forPath("/my");
                Thread.sleep(1000);

                client.setData().forPath("/my", "666".getBytes());

            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
}

public static void main(String[] args) {
    CuratorTest test = new CuratorTest();
    test.set();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>这种调用方式是比较原始的进程间通信，以此为基础，recipes已经实现了一系列通信的高级语意，
如lock、semaphore、确认leader等，可以直接使用。</p>
]]></content>
  </entry>
  
</feed>
