<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: java | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2020-09-10T18:00:35+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[查看java的线程cpu使用情况]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2020/06/24/cha-kan-javade-xian-cheng-cpushi-yong-qing-kuang/"/>
    <updated>2020-06-24T22:36:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2020/06/24/cha-kan-javade-xian-cheng-cpushi-yong-qing-kuang</id>
    <content type="html"><![CDATA[<p>说来惭愧，那么些年写java，至今也没碰到需要对jvm内部线程cpu使用情况的研究。
今天碰到一例，因为用了flink，出现了一个处理瓶颈，不得不深入一探究竟。</p>

<p>就Linux的操作系统原理而言，jvm的线程是类似进程的东西，通过<code>top -Hn 14142</code> 可以查看到
14142这个进程内所有线程的cpu使用情况</p>

<p><code>
 PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
14321 hadoop    20   0   17.7g   8.6g  27756 S 43.2 27.4   8:29.33 java
14275 hadoop    20   0   17.7g   8.6g  27756 S 15.9 27.4   2:45.05 java
14408 hadoop    20   0   17.7g   8.6g  27756 S  3.7 27.4   0:33.23 java
14274 hadoop    20   0   17.7g   8.6g  27756 S  2.3 27.4   0:37.25 java
14226 hadoop    20   0   17.7g   8.6g  27756 S  2.0 27.4   0:20.27 java
14222 hadoop    20   0   17.7g   8.6g  27756 S  1.3 27.4   0:12.78 java
14414 hadoop    20   0   17.7g   8.6g  27756 S  1.3 27.4   0:11.12 java
14254 hadoop    20   0   17.7g   8.6g  27756 S  1.0 27.4   0:10.05 java
14288 hadoop    20   0   17.7g   8.6g  27756 S  1.0 27.4   0:11.97 java
14415 hadoop    20   0   17.7g   8.6g  27756 S  1.0 27.4   0:10.99 java
15072 hadoop    20   0   17.7g   8.6g  27756 S  1.0 27.4   0:11.04 java
</code></p>

<p>可以发现，14321 14275 这两个线程使用的cpu最多，那么这两个线程对应的算子是什么呢？这里就需要使用到jstack</p>

<p><code>jstack 14142 &gt; flink.dump</code></p>

<p>就可以得到jstack的信息。注意，需要以java进程运行用户的身份来运行上面的命令。</p>

<p>可以得到下面这些东西：</p>

<p>```
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.131-b11 mixed mode):</p>

<p>"Attach Listener" #3673 daemon prio=9 os_prio=0 tid=0x00007f76403d6000 nid=0x676d waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE</p>

<p>"flink-metrics-22" #3672 prio=1 os_prio=0 tid=0x0000000002ef6000 nid=0x674f waiting on condition [0x00007f75bd85d000]
   java.lang.Thread.State: TIMED_WAITING (parking)</p>

<pre><code>    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  &lt;0x00000004406d94d8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
    at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)
    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1066)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:748)
</code></pre>

<p>"flink-akka.actor.default-dispatcher-33" #3668 prio=5 os_prio=0 tid=0x00007f765db5f800 nid=0x66d8 waiting on condition [0x00007f75bf67d000]
```</p>

<p>jstack输出的hex也就是16进制的，所以我们需要把pid再做一下转换。使用python可以调用hex方法.</p>

<p>```
Python 3.6.8 (default, Aug  7 2019, 17:28:10)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type "help", "copyright", "credits" or "license" for more information.</p>

<blockquote><blockquote><blockquote><p>hex(14321)
'0x37f1'
hex(14275)
'0x37c3'
```</p></blockquote></blockquote></blockquote>

<p>然后在dump文件中搜索<code>0x37f1</code>，可以得到</p>

<p>```
"at35__process -> (at35_e -> Sink: at35_sink, at35_current_parameter, at35_current_state) (1/1)" #142 prio=5 os_prio=0 tid=0x00007f7648a78800 nid=0x37f1 in Object.wait() [0x00007f75d53d6000]
   java.lang.Thread.State: WAITING (on object monitor)</p>

<pre><code>    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:502)
    at org.apache.flink.runtime.io.network.partition.consumer.UnionInputGate.waitAndGetNextInputGate(UnionInputGate.java:211)
    - locked &lt;0x0000000441ab5ae8&gt; (a java.util.ArrayDeque)
    at org.apache.flink.runtime.io.network.partition.consumer.UnionInputGate.getNextBufferOrEvent(UnionInputGate.java:169)
    at org.apache.flink.streaming.runtime.io.BarrierBuffer.getNextNonBlocked(BarrierBuffer.java:165)
    at org.apache.flink.streaming.runtime.io.StreamTwoInputProcessor.processInput(StreamTwoInputProcessor.java:273)
    at org.apache.flink.streaming.runtime.tasks.TwoInputStreamTask.run(TwoInputStreamTask.java:117)
    at org.apache.flink.streaming.runtime.tasks.StreamTask.invoke(StreamTask.java:300)
    at org.apache.flink.runtime.taskmanager.Task.run(Task.java:711)
    at java.lang.Thread.run(Thread.java:748)
</code></pre>

<p>```</p>

<p>```
"at20_window -> (at20__message, at20_current_parameter, at20_current_state) (1/1)" #112 prio=5 os_prio=0 tid=0x00007f76485f1800 nid=0x37c3 in Object.wait() [0x00007f75d7af9000]
   java.lang.Thread.State: WAITING (on object monitor)</p>

<pre><code>    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:502)
    at org.apache.flink.runtime.io.network.partition.consumer.UnionInputGate.waitAndGetNextInputGate(UnionInputGate.java:211)
    - locked &lt;0x0000000441a00cc8&gt; (a java.util.ArrayDeque)
    at org.apache.flink.runtime.io.network.partition.consumer.UnionInputGate.getNextBufferOrEvent(UnionInputGate.java:169)
    at org.apache.flink.streaming.runtime.io.BarrierBuffer.getNextNonBlocked(BarrierBuffer.java:165)
    at org.apache.flink.streaming.runtime.io.StreamTwoInputProcessor.processInput(StreamTwoInputProcessor.java:273)
    at org.apache.flink.streaming.runtime.tasks.TwoInputStreamTask.run(TwoInputStreamTask.java:117)
    at org.apache.flink.streaming.runtime.tasks.StreamTask.invoke(StreamTask.java:300)
    at org.apache.flink.runtime.taskmanager.Task.run(Task.java:711)
    at java.lang.Thread.run(Thread.java:748)
</code></pre>

<p>```</p>

<p>然后就可以看见线程的名字，就可以去代码里进一步对症下药了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[坚持的成果]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2019/02/03/jian-chi-de-cheng-guo/"/>
    <updated>2019-02-03T23:47:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2019/02/03/jian-chi-de-cheng-guo</id>
    <content type="html"><![CDATA[<p>坚持，始终是一种美德。
在软件开发的世界里，Java坚持了很多年，Mybatis也坚持了很多年。
尽管动态语言是那么的适合web开发，以至于Java在他们面前有好几年十分的被动。但通过Spring的IOC等特性，
生生造出来了一个具备很多动态语言特性的框架，从而具备了很多原本只有动态语言才具备的特性。</p>

<p>另外，Mybatis从一个起初土的掉渣的东西，经过十几年持续有人使用的努力，现在竟然在mybatis-plus的帮助下形成了
Java持久层最出色的一员。在兼容Mybatis的基础上，完全具备了JPA的优势，但在查询和支持SQL上又要远较JPA灵活许多。
因为坚持，实现了巨大的超越。</p>

<p>所以，有时候我们需要有点耐心，坚持一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clean Code]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2018/05/01/clean-code/"/>
    <updated>2018-05-01T14:23:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2018/05/01/clean-code</id>
    <content type="html"><![CDATA[<p>Uncle Bob的这本书也是一本名著了，书籍本身其实就是讲编程风格的，可以把编码技能磨砺的
更锋利些。</p>

<p>全书的要旨在于每一次重构都要让代码更加整洁，同时测试代码和业务代码一样对待。具体开始做起来，则是从很小之处开始着手。</p>

<ol>
<li><p><strong>命名</strong>是很重要的一个东西，好的命名可以省下很多注释，因为好的命名本身就帮助理解程序。命名包括了方法名和变量名。</p></li>
<li><p><strong>函数</strong>要尽可能的短，比如20行，可以在一屏里面显示，如果一个方法太长，那么肯定是命名没有弄好，可以继续拆分。此外，<strong>参数</strong>要尽可能的少，能不要参数就不要参数，一个参数好于二个参数，二个参数好于三个参数，三个参数是大部分方法的极限。</p></li>
<li><p><strong>注释</strong>以阐述为主，不要使用太多的废话，如果确定要写注释，也要认真编写。</p></li>
<li><p><strong>格式</strong>是多个代码之间的关联和布局规则。Bob推荐类似报纸的编写方式，大标题后面跟随小标题，比如大的<code>public</code>方法后面跟随小的<code>private</code>方法。和函数的规则一样，垂直相关的内容尽量放在一起。</p></li>
<li><p><strong>数据和对象</strong>牵涉偏向过程还是偏向面向对象。对于面向对象来讲，一般不增加method而是增加类型，对面向过程来讲，一般增加方法而不动数据结构，现实中肯定是二者皆有。</p></li>
<li><p><strong>错误处理</strong>错误处理粗返回码外，也可以考虑使用异常来进行封装。</p></li>
<li><p><strong>边界</strong>划分好后，对第三方的库和方法要单独测试和封装，以减少对本系统的影响。</p></li>
<li><p><strong>类</strong>也要单一权责，内聚，可以用许多短小的类来构建程序。</p></li>
</ol>


<p>多用<code>Enum</code>，少用<code>const</code><br/>
多用<code>strategy</code>, <code>template</code>，少用<code>if</code>, <code>switch</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Java 3rd Edition]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2018/02/20/effective-java-3rd-edition/"/>
    <updated>2018-02-20T23:01:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2018/02/20/effective-java-3rd-edition</id>
    <content type="html"><![CDATA[<p>「Effective Java」第三版在过年期间出版了，对比第二版主要补充了<code>lambda</code>和<code>stream</code>的内容，序列化方面
则希望大家不要再使用java原生的内容，其他变化不大。但是，和第一版比较起来，变化就很大了。除上述内容外，
第二版较第一版增加了<code>autoboxing/autounboxing</code>，<code>enum</code>, <code>annotation</code>,<code>generic programming</code>, 整个的编程建议也从57条增长到78条再到第三版的90条。</p>

<p>借用作者在第三版的前言，在1997年，Java的创始者Gosling描述java是一种“蓝领语言”（blue collar language），意味着当时的java相当简单（pretty simple）。与此同时，C++的创始人Stroustrup则警告所谓java的简单和其他很多新语言一样，只是误解以及功能上的不完善，随着时间的流逝，Java在尺寸和复杂性上都将大规模成长。不得不说，三者都是大师，而Java虽然依旧还是工业级的语言，但复杂度和规模已经较我十几年前初学时多了许多。或许，也因此大学里正在寻求一门其他语言来取代Java的教学地位吧。</p>

<p>此书非常经典，虽然作者说不用从头到尾通读，但是，建议还是全部都读一遍，甚至可能需要反复阅读并加以实践。比如其中的primitives和boxed primitives，即<code>int</code>和<code>Integer</code>，其间的坑在新项目中就踩过，而之前阅读后只是尽量不去用Integer这些boxed的类型，而这个新项目中由于前后交互的需要必须使用了Integer，于是就把<code>==</code>, 内容为<code>null</code>的坑都踩到了。</p>

<p>开卷有益，何况经典！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring cloud 服务治理]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/10/07/spring-cloud-fu-wu-zhi-li/"/>
    <updated>2017-10-07T13:54:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/10/07/spring-cloud-fu-wu-zhi-li</id>
    <content type="html"><![CDATA[<p>服务治理是近年来架构中的热点部分，尽管比照ICE这些内容其实十几年前就已经有了，
只是五六年前伴随着系统越做越庞大，才变得必要起来。</p>

<p>简单理解一下，其主要内容基本是：</p>

<ul>
<li>要有一个服务中心，服务中心最好是集群的</li>
<li>要能向中心注册服务，服务的地址用名称而不是ip硬绑</li>
<li>要能发现一个服务，其实就是用名称通过服务中心找到服务的ip和端口</li>
<li>要一个可以轮流访问服务集群的客户端</li>
<li>此外再配合上消息总线等内容</li>
</ul>


<p>有了这些，基本一个服务治理的框架就基本形成了。</p>

<p>《Spring Cloud 微服务实战》是一本很不错的书，有动手的介绍，有源码的分析，写的也算精炼。</p>

<h3>Eureka 服务治理中心</h3>

<p>启动服务中心后，配置客户端主要包含两部分：</p>

<ul>
<li>服务注册相关信息： 包括服务中心地址、服务获取间隔时间、可用区域，以<code>eureka.client</code>为前缀</li>
<li>服务实例相关的配置信息： 包括实例的名称、IP地址、端口号、健康检查路径等，以<code>eureka.instance</code>为前缀</li>
</ul>


<h3>Ribbon</h3>

<p>Spring Cloud的负载均衡是在客户端实现的。
<code>WeightedResponseTimeRule</code>是个比较复杂的实现。</p>

<h3>Hystrix</h3>

<p>这是一个容错断路器，当出现超时等状况时直接调用指定的回掉函数。使用了RxJava库的异步操作模式，
实现了发送+观察的效果，所以可以中断请求。</p>

<h3>Feign</h3>

<p>在RestTemplate上进一步抽象，实现和Spring MVC对等的method封装。因为要组client，所以<code>@RequestParam</code>
中的value不能少。</p>

<p>```java
@FeignClient("Hello-Service")
public interface HelloService {
  @RequestMapping(value="/hello1", method=RequestMethod.GET) //指明要访问的路径和方法
  User hello(@RequestParam("name") String name, @RequestHeader("age") Integer age); //指明构造请求是的参数名称
}</p>

<p>//调用方式
helloService.hello("DiDi", 30);
```</p>

<h3>Zuul Api 网关</h3>

<p>网关的事情就两条：<br/>
1. 路由
2. 过滤</p>

<p>Zuul的路由结合了治理服务，下面就把一个路径全部转发去了一个服务</p>

<p><code>
zuul.routes.service-a.path=/aaa/**
zuul.routes.service-a.serviceId=Hello-Service
</code>
过滤器则可以通过继承一个抽象类<code>ZuulFilter</code>并实现4个方法来实现。</p>

<p>```java
public class AccessFilter extends ZuulFilter {
  ....
}</p>

<p>@EnableZuulProxy
@SpringCloudApplication
public class Application {
  public static void main(String[] args) {</p>

<pre><code>new SpringApplicationBuilder(Application.class).web(true).run(args);
</code></pre>

<p>  }</p>

<p>  @Bean
  public AccessFilter accessFilter() {</p>

<pre><code>return new AccessFilter();
</code></pre>

<p>  }
}
```</p>

<h3>Spring Cloud Config</h3>

<p>基于git（也可以是svn或本地目录）的配置中心，其实就是一个可以保存各种配置信息，然后由其他微服务读取后拉起应用。</p>

<h3>Bus 和 Stream 消息总线和消息流</h3>

<p>目前只支持RabbitMQ和kafka两种队列，kafka更多的好像和实时日志处理流相关</p>
]]></content>
  </entry>
  
</feed>
