<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2017-10-08T23:37:09+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[微服务笔记]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/10/08/wei-fu-wu-bi-ji/"/>
    <updated>2017-10-08T23:02:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/10/08/wei-fu-wu-bi-ji</id>
    <content type="html"><![CDATA[<p>微服务是Martin Fowler定义的一个术语，出自 https://martinfowler.com/articles/microservices.html</p>

<p>是伴随着敏捷开发和云服务部署流行而兴起的一种架构。微服务架构风格[1]是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。</p>

<p>具备的特征包括：</p>

<ul>
<li>水平扩展服务能力时，可以扩展只需要扩展的模块而不是全部</li>
<li>组件多以服务的形式提供</li>
<li>团队多按业务能力/功能组建</li>
<li>团队始终围着产品，而不是做完了就丢给运维</li>
<li>smart endpoints and dumb pipes，其实就是管道扁平化，针对SOA中部分总线太过只能而言</li>
<li>去中心化的管理，微服务意味着可以自治化，而不是谈标准化</li>
<li>可以多个编程语言同时使用，只要保持彼此间通信简单（http+lightweight messaging）</li>
<li>数据存储也是去中心化的，Polyglot Persistence，存储/数据库也是每个服务自己定</li>
<li>基础设施自动化程度高，实现持续提交和持续集成</li>
<li>开发者和用户间会更容易建立更多的联系，要持续关注软件如何帮助用户提升业务能力，而不是把软件看成是将要完成的一组功能</li>
<li>针对失效的设计，使用服务作为组件的一个结果是，应用程序需要被设计成能够容忍服务失效，如断路器模式</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring cloud 服务治理]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/10/07/spring-cloud-fu-wu-zhi-li/"/>
    <updated>2017-10-07T13:54:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/10/07/spring-cloud-fu-wu-zhi-li</id>
    <content type="html"><![CDATA[<p>服务治理是近年来架构中的热点部分，尽管比照ICE这些内容其实十几年前就已经有了，
只是五六年前伴随着系统越做越庞大，才变得必要起来。</p>

<p>简单理解一下，其主要内容基本是：</p>

<ul>
<li>要有一个服务中心，服务中心最好是集群的</li>
<li>要能向中心注册服务，服务的地址用名称而不是ip硬绑</li>
<li>要能发现一个服务，其实就是用名称通过服务中心找到服务的ip和端口</li>
<li>要一个可以轮流访问服务集群的客户端</li>
<li>此外再配合上消息总线等内容</li>
</ul>


<p>有了这些，基本一个服务治理的框架就基本形成了。</p>

<p>《Spring Cloud 微服务实战》是一本很不错的书，有动手的介绍，有源码的分析，写的也算精炼。</p>

<h3>Eureka 服务治理中心</h3>

<p>启动服务中心后，配置客户端主要包含两部分：</p>

<ul>
<li>服务注册相关信息： 包括服务中心地址、服务获取间隔时间、可用区域，以<code>eureka.client</code>为前缀</li>
<li>服务实例相关的配置信息： 包括实例的名称、IP地址、端口号、健康检查路径等，以<code>eureka.instance</code>为前缀</li>
</ul>


<h3>Ribbon</h3>

<p>Spring Cloud的负载均衡是在客户端实现的。
<code>WeightedResponseTimeRule</code>是个比较复杂的实现。</p>

<h3>Hystrix</h3>

<p>这是一个容错断路器，当出现超时等状况时直接调用指定的回掉函数。使用了RxJava库的异步操作模式，
实现了发送+观察的效果，所以可以中断请求。</p>

<h3>Feign</h3>

<p>在RestTemplate上进一步抽象，实现和Spring MVC对等的method封装。因为要组client，所以<code>@RequestParam</code>
中的value不能少。</p>

<p>```java
@FeignClient("Hello-Service")
public interface HelloService {
  @RequestMapping(value="/hello1", method=RequestMethod.GET) //指明要访问的路径和方法
  User hello(@RequestParam("name") String name, @RequestHeader("age") Integer age); //指明构造请求是的参数名称
}</p>

<p>//调用方式
helloService.hello("DiDi", 30);
```</p>

<h3>Zuul Api 网关</h3>

<p>网关的事情就两条：<br/>
1. 路由
2. 过滤</p>

<p>Zuul的路由结合了治理服务，下面就把一个路径全部转发去了一个服务</p>

<p><code>
zuul.routes.service-a.path=/aaa/**
zuul.routes.service-a.serviceId=Hello-Service
</code>
过滤器则可以通过继承一个抽象类<code>ZuulFilter</code>并实现4个方法来实现。</p>

<p>```java
public class AccessFilter extends ZuulFilter {
  ....
}</p>

<p>@EnableZuulProxy
@SpringCloudApplication
public class Application {
  public static void main(String[] args) {</p>

<pre><code>new SpringApplicationBuilder(Application.class).web(true).run(args);
</code></pre>

<p>  }</p>

<p>  @Bean
  public AccessFilter accessFilter() {</p>

<pre><code>return new AccessFilter();
</code></pre>

<p>  }
}
```</p>

<h3>Spring Cloud Config</h3>

<p>基于git（也可以是svn或本地目录）的配置中心，其实就是一个可以保存各种配置信息，然后由其他微服务读取后拉起应用。</p>

<h3>Bus 和 Stream 消息总线和消息流</h3>

<p>目前只支持RabbitMQ和kafka两种队列，kafka更多的好像和实时日志处理流相关</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java新的兼容性挑战者Kotlin]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/05/21/javaxin-de-jian-rong-xing-tiao-zhan-zhe-kotlin/"/>
    <updated>2017-05-21T16:39:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/05/21/javaxin-de-jian-rong-xing-tiao-zhan-zhe-kotlin</id>
    <content type="html"><![CDATA[<p>520期间被刷屏的除了show 恩爱，就是Kotlin了。
原本只是在一个做安卓的小朋友发的pdf里看见了Kotlin，想想应该又是一个和scala groovy或者closure类似的东西---
可以跑在jvm上，能利用jdk的库，语言表达力又强于java。</p>

<p>Java尽管有点啰嗦，语言表达力确实一般，但企业级的支持很强，jvm的性能更是出色，所以在类库、ide、甚至大型开发框架方面是无与伦比的。在jvm上跑的语言很多，甚至想部分替代的如scala closure groovy等等都火过一阵子，但是java继续维持着自己的优势地位。</p>

<p>然而这次真正被刷屏的，是因为Google认了Kotlin为<strong>干儿子</strong>，甚至以后可能是亲儿子，将kotlin变成了
头等安卓开发语言。查了一下，此前获得此定位的仅有java，这就可能有很大的不同了。kotlin有了google的支持，而其他所谓挑战者可没这个干爹。并且，Kotlin的创建者又是目前最流行的java ide的公司贡献的，可以保证在<strong>开发工具上的体验和支持</strong>，这么看来它的优势就比scala等强多了。</p>

<p>希望还是能帮助java改进吧，当然这个有点难，即使java8好几年下来了，也不知道有没有普及率超过java程序员的50%</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[thymeleaf感想]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/05/21/thymeleafgan-xiang/"/>
    <updated>2017-05-21T00:07:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/05/21/thymeleafgan-xiang</id>
    <content type="html"><![CDATA[<p>刚使用spring boot时得知thymeleaf取代了jsp的默认地位，我是有所抵触的，做法就是重新配置回了jsp。
然而随着java web开发前后端业已分离的现实，逐步明白view层是thymeleaf还是jsp已经不再重要。因为java已变成
服务成守候在服务器侧，而原先页面的工作已经完全交给了（不需要会java）的前端人员，且他们是完全可以胜任的。</p>

<p>实际上截至目前，最新版的thymeleaf已经到了3.0以上的版本，而spring boot最新版集成的还是<strong>2.x</strong>的thymeleaf的版本，
可以认为这块已经处于冷淡的状态。</p>

<p>不过，凡是总有例外。这次又碰见了需要产生静态页面的业务场景，其中有不少的业务逻辑，所以还是需要一个view层，考虑到
新团队的习惯，决定采用thymeleaf吧，这样以后维护可以交给前端来做。于是简易学习了一下leaf，感觉还是不错的。</p>

<p>leaf最大的特色就是前端人员可以直接打开leaf所在的html页面，并做到完全的无异物感。脚本、链接完全动态静态可以分开。
这样解决了jsp长期以来美工介入很困难的问题,同时做的又比freemaker等更加到位。内置标签支持的语言语法也很现代化和好用，一般有jsp经验的程序员，
花个半天看一下一百来页的手册并动手实践一下，就完全可上手了。至于<code>jsp</code>，是可以退出历史舞台了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Truffle And Solidity]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/05/01/truffle-and-solidity/"/>
    <updated>2017-05-01T10:11:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/05/01/truffle-and-solidity</id>
    <content type="html"><![CDATA[<p>区块链应用的开发，主要指用<code>Solidity</code>编写合约(Contract)，然后部署到区块链上去。
注意，此处的区块链特指<code>以太坊</code>，而比特币的区块链是没有Solidity这种东西的。</p>

<p>因为是把sol编写的合约部署到区块链上去，所以可以进一步分解为3个问题：</p>

<ol>
<li>区块链的安装(testrpc ethereum)</li>
<li>sol合约编写(Solidity)</li>
<li>对sol合约进行编译以及发布(truffle)</li>
</ol>


<p>目前来看，整个以太坊很喜欢借用node即javascript来构建他们的环境，尽管区块链和sol本身其实和javascript关系不大。
关于ethereum可查相关的安装手册，这里主要记录一下Solidity和truffle。</p>

<p>Sol的编辑器可以用atom vscode等等，submiline也没问题。
这门语言其实还是比较原始的，合约间的调用甚至不能传递结构（struct），更可悲的是返回string也不行。基本上任何不定长的返回
在sol的ethvm（以太坊虚拟机）中都不太好调用。
功能上来讲，solidity可以理解成数据存放在一个类似levelDB的内存数据库，这是ethvm会做的事情。
```javascript</p>

<p>  mapping(uint=>LibDisSecPledgeApply.DisSecPledgeApply)  disSecPledgeApplyMap;</p>

<pre><code>uint[] disSecPledgeApplyIds;
</code></pre>

<p>```</p>

<p>上述代码定义了一个用于存放对象数据的mapping，因为mapping无循环遍历的功能，所以又增加了一个ids的数组保留所有对象的编号。</p>

<p>整个合约的编写，其实对写惯后台程序的人来讲还是不难上手的（类似用java操作redis写业务逻辑），只是限制确实比较多。
但solidity可以支持的变化太少，所以写起来是复杂不到哪里去。相当于成熟的脚本或编译型语言，solidity麻烦的地方在于其调试，
可简单罗列的就有两点：</p>

<ol>
<li>编译速度慢。十几个文件的情况下，用 truffle编译就要3分钟以上</li>
<li>发布调试困难。必须发布到某个链的环境才能测试，而这个就真的很不友好了，断点还不支持，日志也很麻烦。</li>
</ol>


<p>truffle是现在以太坊主要推荐的编写solidity的编译、测试运行和部署工具，能处理较复杂的sol文件关联引用，就是耗时很长，且
程序版本很不稳定，变化发展都依然极快。truffle是基于node和npm的，所以要先装好node。</p>

<p><code>javascript
npm uninstall truffle
npm install -g truffle@2.1.2
truffle compile  //编译合约
truffle migrate --reset //部署合约
truffle exec xxxx.js //执行某个js文件
</code></p>

<p>和区块链一样，solidity，truffle都是刚刚涌现的东西，所以问题很多，用起来也不一定顺手。但，这个行业就是这样的。</p>
]]></content>
  </entry>
  
</feed>
