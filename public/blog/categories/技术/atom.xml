<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2017-02-02T14:27:31+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[区块链功课]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/02/02/qu-kuai-lian-gong-ke/"/>
    <updated>2017-02-02T13:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/02/02/qu-kuai-lian-gong-ke</id>
    <content type="html"><![CDATA[<p>https://www.igvita.com/2014/05/05/minimum-viable-block-chain/</p>

<p>Google的工程师讲解的P2P去中心化现金交易的底层技术---区块链（Block Chain），然后发现区块链的一大基石
是公钥私钥的加密技术，所以作者拿出了经典的Alice Bob来作为举例。</p>

<h2>中心化的支付技术</h2>

<p>目前的支付系统流行的是triple-entry 记账方式。三联为Alice Bob 和Chuck（中心节点，比如银行）都记录着交易记录，
以保证交易的可靠性和非重复性。
这套系统运作的前提是大家都信任Chuck。</p>

<h2>去中心化的难点</h2>

<h3>1. 一致性问题</h3>

<p>去中心化后，系统变成了分布式的，而分布式在一致性方面先天弱于中心化的。处理<strong>Double-spending</strong>的问题是一个难点。
因为一个交易发生后，系统中的其他参与者往往并不知道已经发生，可能还认为Bob拥有大量的钱财。在一个小的系统里，
可以通过全部完成通知后才认可交易成功，而这对一个大规模系统基本不可行。CAP理论表明P2P系统很难支持强一致性，但是，区块链技术
的亮点在于实现了weak(er) consistency。</p>

<h3>2. Sybil attacks （西比尔攻击）</h3>

<p>该攻击的特色在于虚拟出许多虚假的交易者，让真实的交易者误以为消费已经坐实。解决办法是增加造假的成本，同时保持验证的
成本够低，通过经济杠杆来从结构上阻止有人愿意造假，因为得不偿失就是傻事了。</p>

<p>但这带来的一个问题就是单个交易成本会很高，如果交易的手续费高于交易本身，那么这套系统也是没法运行的。</p>

<h3>Block的概念</h3>

<p>Block就是一组交易的集合，不单如此每个Block还记录了前一个Block，从而构成了Block Chain区块链。
每个交易者都可以将有效的交易集合生成一个block，生成block需要耗费大量的计算资源。
而将验证成本集中成Block的好处就是降低了每笔交易的成本，或者说交易集合共同承担了手续成本。而对交易有效性的、一致性、Sybil attacks的
防范都基于Block来进行。</p>

<h3>Block Chain的冲突</h3>

<p>因为所有的参与者都可以生成Block，所以一笔交易可能会加入在多个Block里。此时就构成了冲突，出现了chain fork。Block Chain对此的解决方式很简单粗暴，
永远选择最长的那个chain fork作为“真实的”交易链，并丢弃之前的交易分支。</p>

<p>使用的技术都是现成的：</p>

<ul>
<li>accounting</li>
<li>cryptography</li>
<li>networking</li>
<li>proof-of-work</li>
</ul>


<p>然而集合起来就又构成了一个新的精巧的方案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[zookeeper]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/01/15/zookeeper/"/>
    <updated>2017-01-15T10:27:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/01/15/zookeeper</id>
    <content type="html"><![CDATA[<p>用于协作的服务，提供目录树的结构。基本可以认为是Yahoo出品。</p>

<p>data registers - called znodes, file
parlance - directory</p>

<p>数据全部保存在内存中。</p>

<p>优势：
1. 性能好，可在大规模的分布式系统里使用
2. 可靠性高，可防止单点故障
3. 严格的顺序性，可满足复杂的、高精的客户端同步实现要求</p>

<p>znode的读写有acl控制以及版本号</p>

<p>leader nodes负责接受写的请求，follower nodes负责被同步和读取</p>

<p>配置示例</p>

<p><code>
tickTime=2000
dataDir=/var/lib/zookeeper
clientPort=2181
initLimit=5
syncLimit=2
server.1=zoo1:2888:3888
server.2=zoo2:2888:3888
server.3=zoo3:2888:3888
</code></p>

<p>tickTime是一个即使单元，单位是毫秒，2000表示2秒。<br/>
dataDir是存放数据文件的物理位置。<br/>
initLimit表示n个tickTime，上面这个就是10秒的意思，表示连接上leader nodes需要的时间单元数量。<br/>
syncLimit表示山离皇帝能有多远过期<br/>
server.1中的1的服务器内部的<code>myid</code>，zoo1是服务器地址，第二个port即2888用于follewer连接leader，
第三更port 3888用于选举leader。</p>

<p>基本上，zookeeper可以理解成一个分布式系统里，用于进程间通信的中间件，所以剩下的就是客户端调用了。
项目本身提供了C和Java的binding，具体实现时每个客户端会分为IO线程和watch线程两个。而Netflix在此基础上，
构造了wrapper: <code>curator</code>，以方便开发。</p>

<p>首先，引入maven依赖:</p>

<p>```
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;  
&lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;  
&lt;version&gt;3.2.1&lt;/version&gt;  
</code></pre>

<p></dependency>
```</p>

<p>然后，在代码中可如下调用：</p>

<p>```java
package zookeepertest;</p>

<p>import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;</p>

<p>public class CuratorTest {</p>

<pre><code>public void set() {
    String zookeeperConnectionString="127.0.0.1:2181";
    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
            CuratorFramework client = CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);


            client.start();

            try {
                client.create().forPath("/my", "555".getBytes());

                client.getData().forPath("/my");
                Thread.sleep(1000);

                client.setData().forPath("/my", "666".getBytes());

            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
}

public static void main(String[] args) {
    CuratorTest test = new CuratorTest();
    test.set();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>这种调用方式是比较原始的进程间通信，以此为基础，recipes已经实现了一系列通信的高级语意，
如lock、semaphore、确认leader等，可以直接使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx 通过Lua输出response body]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/08/25/nginx-tong-guo-luashu-chu-response-body/"/>
    <updated>2016-08-25T23:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/08/25/nginx-tong-guo-luashu-chu-response-body</id>
    <content type="html"><![CDATA[<p>Nginx默认是不只支持<code>$request_body</code> 而不支持response的body输出的。这个设定是合理的，因为大量的html响应或者静态文件的内容输出将使得整个日志毫无意义。
然而，response body输出对api的请求来讲，则很多时候、尤其是在调试的时候是很有必要的。取代了抓包的作用，且简单直观许多。
搜寻之下，发现使用lua的话，可以达到此目的。</p>

<ol>
<li>下载并安装lua语言的安装包</li>
</ol>


<p><code>
 wget http://luajit.org/download/LuaJIT-2.0.3.tar.gz
tar -zxvf LuaJIT-2.0.3.tar.gz
cd LuaJIT-2.0.3.tar.gz
make &amp;&amp; make install
</code>
注意，可能你的服务器的wget会实际下载一个html到本地导致tar解压失败，此时可以用浏览器下载完毕后再次上传到服务器上。</p>

<ol>
<li>下载并解压ngx_devel_kit套件</li>
</ol>


<p><code>
wget https://github.com/simpl/ngx_devel_kit/archive/v0.2.19.tar.gz
tar v0.2.19
</code></p>

<ol>
<li>下载并解压lua-nginx-module模块</li>
</ol>


<p><code>
wget https://github.com/chaoslawful/lua-nginx-module/archive/v0.9.6.tar.gz
tar v0.9.6
</code></p>

<ol>
<li>下载并解压nginx后，使用下面的命令重新编译nginx</li>
</ol>


<p>```
./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_flv_module --with-http_gzip_static_module --with-pcre --sbin-path=/usr/sbin/nginx --add-module=/root/lua-nginx-module-0.9.6 --add-module=/root/ngx_devel_kit-0.2.19
make &amp;&amp; make install
cp /usr/sbin/nginx /usr/local/nginx/sbin/</p>

<p>```</p>

<p>最后，在nginx的conf文件中的<code>server{}</code>上下文里加入下面代码</p>

<p>```
log_format  main_with_response  '$remote_addr - $remote_user [$time_local] "$request" '</p>

<pre><code>                  '$status $body_bytes_sent "$http_referer" '
                  '"$http_user_agent" "$http_x_forwarded_for"'
                  'request: "$request_body"' 'response: $resp_body';
</code></pre>

<p>server {</p>

<p>...
   lua_need_request_body on;</p>

<pre><code>set $resp_body "";
body_filter_by_lua '
    local resp_body = string.sub(ngx.arg[1], 1, 1000)
    ngx.ctx.buffered = (ngx.ctx.buffered or "") .. resp_body
    if ngx.arg[2] then
         ngx.var.resp_body = ngx.ctx.buffered
    end
';

   location /xxxx {
        root   html;
        access_log  logs/access.log  main_with_response;
        proxy_pass http://192.168.203.198:8080;
    }
</code></pre>

<p>}
```</p>

<p>为避免response溢出整个日志，可选择在特定的location中使用输出response body。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[openwrt n56u 和iptv]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/04/05/openwrt-n56u-he-iptv/"/>
    <updated>2016-04-05T12:14:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/04/05/openwrt-n56u-he-iptv</id>
    <content type="html"><![CDATA[<p>四年以前写的<a href="/blog/2012/02/20/the-way-to-link-to-iptv-in-shanghai-through-vlan/">上海电信IPTV的VLAN ID和通过交换机连接两路IPTV</a>，而由于4k高清IPTV机顶盒的推广，
当时的内容已经有些不合时宜。尽管，用一个交换机还是可以实现连接两路iptv。</p>

<p>区别主要在于新的4k高清机顶盒同小红等盒子一样，需要双平面才能跑得起来。所谓双平面就是在专网之外机顶盒也要能够连接公网。
这个变化其实是带来一大好处的，即通过一个路由设备接光猫的一个口子，也可以让iptv和公网业务同时跑起来。下面记录一下操作过程。</p>

<h3>openwrt</h3>

<p>首先，这么灵活的配法，当前asus netgear等原厂的固件是不支持此种功能的，所以需要第三方固件，如openwrt dd-wrt。我选择了openwrt，是因为其官网支持asus-n56u路由器。
<a href="https://wiki.openwrt.org/toh/asus/rt-n56u">官方链接</a> ，可以从前面这个链接获得操作过程和固件。注意下载<code>squashfs-factory.bin</code>，不要下载chaos版。我就误下了chaos版，导致只能采用reset的办法重新装回了华硕的固件。openwrt很贴心的一点就是在网页里提供了恢复固件的操作步骤</p>

<p><code>sh
Download &amp; Install the asus "Firmware Restoration" from asus website
Download the factory image from asus
Enter Recovery Mode
Unplug Router
Hold Reset Button and Plug in Router
Release button when front LED flashes slowly
Use the following to set up your TCP/IP settings:IP address: 192.168.1.x Subnet mask: 255.255.255.0
Select firmware *.trx and upload
</code></p>

<p>要点是把本机的ip设置成192.168.1.2,而且如果本机有多块网卡（包括虚拟网卡）则只保留一个连接路由器lan口的网口活跃。这样华硕的固件才
明确会打开这个网口并同已进入恢复模式的路由器相连。有了这个恢复模式存在，意味着asus的这款路由器基本是刷不死的。</p>

<p>安装完openwrt，设置好基本的wan口，我是采用的dhcp方式获取wan地址，就可以进入配置iptv vlan的过程了。</p>

<h3>关于4k高清机顶盒获取公网和专网IP的流程</h3>

<p>参考<a href="https://www.ydkfblog.com/?m=201602">上海电信光猫一体机配合Openwrt拨号正常使用OTT 4K IPTV</a>，
找到了iptv dhcp的流程
<img src="/images/openwrt/4kiptvdhcp.png" alt="image" /></p>

<p>看清流程后，就可以知道：
1. 要先让4k iptv机顶盒接入公网<br/>
2. 路由器要支持DHCP-Option：125<br/>
3. 路由器要支持vlan 85的进出</p>

<p>公网配置是基础，剩余两点的配置可以归纳为</p>

<blockquote><ol>
<li><p>接在自备路由器上时，将路由器WAN口、CPU口、接IPTV的口 一起新建一个VLAN 85，3个端口全部为tagged</p></li>
<li><p><code>/etc/dnsmasq.conf</code>中要加入<code>dhcp-option-force=125,00:00:00:00:1b:02:06:48:47:57:2d:43:54:03:05:48:47:32:32:31:0a:02:20:00:0b:02:00:55:0d:02:00:2e</code> ,即对Option 125的支持</p></li>
</ol>
</blockquote>

<p>做完这些之后，至少目前中兴的机顶盒是全面支持了。</p>

<p>配置附录</p>

<p>/etc/config/network
```
config switch</p>

<pre><code>    option name 'switch0'                                                                                                                                                        
    option reset '1'                                                                                                                                                             
    option enable_vlan '1'                                                                                                                                                       
    option enable_vlan4k '1'                                                                                                                                                     
</code></pre>

<p>config switch_vlan</p>

<pre><code>    option device 'switch0'                                                                                                                                                      
    option vlan '1'                                                                                                                                                              
    option ports '0 1 2 3 8t'                                                                                                                                                    
</code></pre>

<p>config switch_vlan</p>

<pre><code>    option device 'switch0'                                                                                                                                                      
    option vlan '2'                                                                                                                                                              
    option ports '4 8t'                                                                                                                                                          
</code></pre>

<p>config switch_vlan</p>

<pre><code>    option device 'switch0'                                                                                                                                                      
    option vlan '85'                                                                                                                                                             
    option vid '85'                                                                                                                                                              
    option ports '1t 2t 4t 8t'    
</code></pre>

<p>```</p>

<p>/etc/dnsmasq.conf
```</p>

<h1>cname=bertand,bert</h1>

<p>dhcp-option-force=125,00:00:00:00:1b:02:06:48:47:57:2d:43:54:03:05:48:47:32:32:31:0a:02:20:00:0b:02:00:55:0d:02:00:2e
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文艺的HashMap初始化]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua/"/>
    <updated>2015-11-23T20:33:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2015/11/23/wen-yi-de-hashmapchu-shi-hua</id>
    <content type="html"><![CDATA[<p>多年以来，受制于java没有初始设置<code>hash</code>对-值的方法，例如js有：</p>

<p><code>javascript
var obj = {
  a: 1, b: 2
};
</code></p>

<p>ruby在借鉴js的文法之前，有著名的rocket标注</p>

<p><code>ruby
obj = {:a=&gt;1, :b=:2}
</code></p>

<p>而java则只能继续使用过程定义来描述</p>

<p><code>java
Map&lt;String, integer&gt; map = new HashMap&lt;String, integer&gt;();
map.put("a", 1);
map.put("b", 2);
</code></p>

<p>而最近发现了一种文艺一些的写法：</p>

<p>```java
Map&lt;String, integer> map = new HashMap&lt;String, integer>(){
  {</p>

<pre><code>put("a", 1);
put("b", 2);
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>此种写法是利用了创建一个匿名类的文法，该匿名类直接继承自HashMap，而第二套花括弧则是实例初始化。</p>

<p>实例初始化是对应于静态初始化，后者属于整个类，而前者属于某个对象初始化时进行。</p>

<p>```java
public class demo {
  static {</p>

<pre><code>do sth of class
</code></pre>

<p>  }</p>

<p>  {</p>

<pre><code>do sth of instance
</code></pre>

<p>  }
}
```</p>

<p>其实这种写法的代码行数并不少，但是语意，主要是段落的分割清楚了许多。</p>
]]></content>
  </entry>
  
</feed>
