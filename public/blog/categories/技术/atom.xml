<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2021-01-14T21:33:15+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mybatis-plus的字段为复杂对象的读取和装载]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2021/01/14/mybatis-plusde-zi-duan-wei-fu-za-dui-xiang-de-du-qu-he-zhuang-zai/"/>
    <updated>2021-01-14T21:19:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2021/01/14/mybatis-plusde-zi-duan-wei-fu-za-dui-xiang-de-du-qu-he-zhuang-zai</id>
    <content type="html"><![CDATA[<p>如果核心代码写的非常OO，那么Entity中自然会出现很多Value Object。一旦这些VO需要存入数据库，则会牵涉到一个数据库字段转换到Java类型的ORM问题。<br/>
比如有下面的代码：</p>

<p>```java
@Data
// @TableName(autoResultMap = true)
public class Validator {</p>

<pre><code>private Long id;

// @TableField(typeHandler = CommissionTypeHandler.class)
private Commission commission;
</code></pre>

<p>}</p>

<p>public class Commission {</p>

<pre><code>final private BigDecimal commission;
</code></pre>

<p>}
```</p>

<p>Commission作为一个VO，也需要保存到Validator的表格中。Mybatis通过typeHandler的方式来实现这种钩子，完成这种转换。具体做法为先定义相应的handler, 即<code>TypeHandler&lt;T&gt;</code>接口的实现类</p>

<p>```java
import com.walletguard.polkadotprx.entity.Commission;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.MappedJdbcTypes;
import org.apache.ibatis.type.MappedTypes;
import org.apache.ibatis.type.TypeHandler;</p>

<p>import java.math.BigDecimal;
import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;</p>

<p>@MappedJdbcTypes(JdbcType.DECIMAL)  //数据库类型
@MappedTypes(Commission.class)
public class CommissionTypeHandler implements TypeHandler<Commission> {</p>

<pre><code>@Override
public void setParameter(PreparedStatement ps, int i, Commission parameter, JdbcType jdbcType) throws SQLException {
    ps.setBigDecimal(i, parameter.getCommission());
}

@Override
public Commission getResult(ResultSet rs, String columnName) throws SQLException {
    BigDecimal co = rs.getBigDecimal(columnName);
    return new Commission(co);
}

@Override
public Commission getResult(ResultSet rs, int columnIndex) throws SQLException {
    BigDecimal co = rs.getBigDecimal(columnIndex);
    return new Commission(co);
}

@Override
public Commission getResult(CallableStatement cs, int columnIndex) throws SQLException {
    BigDecimal co = cs.getBigDecimal(columnIndex);
    return new Commission(co);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>该接口有4个需要实现的method，其中3个是读取，1个是写入，这里又用到了很传统的JdbcTemplate的方式类设置和读取相应的值，读出后转换成自己需要的对象。
<code>MappedJdbcTypes</code>指明了Jdbc中的类型， <code>MappedTypes</code>指明了OO中的对象类型，也就是接口<code>TypeHandler&lt;T&gt;</code>中的T。</p>

<p>然后，在上面类型的对象中，作<code>@TableField(typeHandler = CommissionTypeHandler.class)</code>声明，即意味着该字段用这个typeHandler来进行处理。<br/>
但是，这只是确保可以写入，如果要支持读取，还需要在Class的开头，加上<code>@TableName(autoResultMap = true)</code>，这样这个ORM就实现了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clean Architecture]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2020/10/06/clean-architecture/"/>
    <updated>2020-10-06T22:47:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2020/10/06/clean-architecture</id>
    <content type="html"><![CDATA[<p>Rober C. Martin的另一部Clean系列，总体来讲不如Clean Code，但书还值得一读。Bob大叔开发经验丰富，但仔细分析的话，他的主要经验还是基于C的通信软件的开发，之前有过很多的汇编经历。Java看起来真正做过的大的项目似乎并不多。因为按他90年代以前的经历，基本没有使用Java开发过什么，而之后，则转去了做咨询和主编，写的项目按常理应该不多。</p>

<p>书中首先使用龟兔赛跑的隐喻，讽刺了程序员们的迷之自信，总以为自己是聪明的兔子能够有朝一日把一团乱的东西Clean干净，但实际上从来没有发生。以此告诫读者必须脚踏实地做好整洁架构和整洁代码：The only way to go fast is to go well. 随后，提出Software的精髓在于<strong>soft</strong>，也就是easy to change，这是软件设计和开发的根本。并且应用类软件的开发，一般是由urgent behavior驱动的，但维护好clean Architecture则是开发人员的责任。</p>

<p>第二部分里，讲了3种基本的编程范式，强调的都是纪律的重要性。如结构化编程取消了goto，只保留了if/then/else,
do/while/until; OO则是限制函数间的调用，抽象、封装、继承、多态，并且举了IO device的C接口的例子。同时提出了<strong>Plugin</strong>架构的思想。因为所有的Device其实都是作为一种附件，plugin到OS上面去的。接口是OS定义的，实现则是plugin的事情。</p>

<p>第三第四部分则是作者提出过的SOLID设计原理以及组件的原理。<br/>
SRP，OCP，LSP，ISP，DIP。一个Module应该只对一个Actor负责。Actor通常是source，是使用者。<br/>
组件主要是耦合问题。REP、CCP、CRP，这其实是一个CAP的不可能三角。组件之间要削减循环依赖，被依赖多的Stable，不被依赖的Unstable，Stable的东西需要加入Abstract来实现弹性的增加。同时要减少对易变（volatile）组件的依赖，即在Stable的东西中加入Abstract以使软件变软。</p>

<p>第五部分是全书的的主体，主讲架构。<br/>
架构的目的是为了便于软件开发、部署、运行（非功能性要求）。维护，让细节开放，这样细节可以很晚才被决定。架构师的目标则是make software soft， 实现Policy和Detail之间的decouple，同时也负责设计Policy。</p>

<p>所谓Policy指business rules and procedures，Detail则是和policy进行通信的东西。架构师的一大职责，就是在Details之间画下边界线（boundary line）。而Clean Architecture则是让Details依赖Policy的一种架构方式。也体现了Bob大叔的DIP原则，即反转依赖。低级的组件应该作为插件插入到高级组件中去，高级组件是Policy和Use cases。
这个好处是减少核心内容的复杂性和对外部的依赖。
同时，架构是关于系统的，不是关于框架的，提出了架构设计要和框架尽可能分离的概念。即Domain优先，能让人看了架构设计图就知道系统是干什么的，举了图书馆、住房的设计图例子。这样也容易形成Testable Architecture。但这种做法下，架构师就变成了传统的系统分析师。</p>

<p>举了几种Clean Architecture，主要就是Ports and Adapters（Hexagonal Architecture）。也提到了Humble模式。架构即画边界以及决定用什么作边界，Humble Objects用于架构边界处。</p>

<p>至于微服务，作者的意思是service并不是分界线，分界线在service内部，举了Kitty Finder和Ride Finder的例子。从这点来说，熔断可以作为某种服务的一种多态实现。所以K8S其实也可以实现熔断，比如在一个Login的service中部署两个不同的service，确定某一个在什么情况下生效。</p>

<p>Test可以作为系统第一部分，而且是最外层的，因为所有的代码都不依赖测试代码，而测试代码却依赖其他代码（Domain+Infrastructure）。但对测试解耦，并没有提出什么实质性的建议。</p>

<p>最后，DB、Web、Framework都是小把戏（Detail），应用本身才是大Boss，不要为了Detail而限制Boss。又举了一个作者自己卖网课的例子，但这个例子实在太短，看不出什么名堂来。</p>

<p>结束后，其实还有两大部分，一个是Simon Brown写的一章，列举了4种常见的代码目录组织方式，并提出组织之间最大的区别在于包内方法的可见性差异。Simon创造了C4架构模型，这章列举的也不错，但例子还是太浅和理想化了，设计细节太少。  另外一部分就是Bob大叔的前半生开发生涯自传，写到了1990年代。里面补充到之后的经历会写成另一本书，应该就是今年出的Clean Agile了吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git 删除已提交的文件]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2020/09/10/git-shan-chu-yi-ti-jiao-de-wen-jian/"/>
    <updated>2020-09-10T17:41:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2020/09/10/git-shan-chu-yi-ti-jiao-de-wen-jian</id>
    <content type="html"><![CDATA[<p>按台湾人的说法，git属于一旦有东西加入，就像把方丈请到了庙里，是很难再请出去的。
不过也不是完全不可能，但确实比较辛苦会。核心思想是通过<code>filter-branch</code>
来强制删除有关的文件，过程中类似<code>rebase</code>。在全部的分支、tag、heads、replace的
连接取消之后，再次gc，即可实际清除</p>

<p>```</p>

<h1>找出体积比较大的文件</h1>

<p>git rev-list --objects --all | grep "$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk '{print$1}' )"</p>

<h1>进行删除</h1>

<p>git filter-branch --force --index-filter 'git rm -rf --cached --ignore-unmatch .gradle' --prune-empty --tag-name-filter cat -- --all</p>

<h1>实际删除</h1>

<p>rm -rf .git/refs/original
git reflog expire --expire=now --all
git gc --prune=now
```</p>

<p>不过上述只是完成了本地的内容清理，远端的gitlab还有其他工作要做：</p>

<p><code>
git push origin --force 'refs/heads/*'
git push origin --force 'refs/tags/*'
git push origin --force 'refs/replace/*'
</code></p>

<p>最后，再去gitlab的settings里面手工执行一下Housekeeping，再次clone的话体积就小了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查看java的线程cpu使用情况]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2020/06/24/cha-kan-javade-xian-cheng-cpushi-yong-qing-kuang/"/>
    <updated>2020-06-24T22:36:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2020/06/24/cha-kan-javade-xian-cheng-cpushi-yong-qing-kuang</id>
    <content type="html"><![CDATA[<p>说来惭愧，那么些年写java，至今也没碰到需要对jvm内部线程cpu使用情况的研究。
今天碰到一例，因为用了flink，出现了一个处理瓶颈，不得不深入一探究竟。</p>

<p>就Linux的操作系统原理而言，jvm的线程是类似进程的东西，通过<code>top -Hn 14142</code> 可以查看到
14142这个进程内所有线程的cpu使用情况</p>

<p><code>
 PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
14321 hadoop    20   0   17.7g   8.6g  27756 S 43.2 27.4   8:29.33 java
14275 hadoop    20   0   17.7g   8.6g  27756 S 15.9 27.4   2:45.05 java
14408 hadoop    20   0   17.7g   8.6g  27756 S  3.7 27.4   0:33.23 java
14274 hadoop    20   0   17.7g   8.6g  27756 S  2.3 27.4   0:37.25 java
14226 hadoop    20   0   17.7g   8.6g  27756 S  2.0 27.4   0:20.27 java
14222 hadoop    20   0   17.7g   8.6g  27756 S  1.3 27.4   0:12.78 java
14414 hadoop    20   0   17.7g   8.6g  27756 S  1.3 27.4   0:11.12 java
14254 hadoop    20   0   17.7g   8.6g  27756 S  1.0 27.4   0:10.05 java
14288 hadoop    20   0   17.7g   8.6g  27756 S  1.0 27.4   0:11.97 java
14415 hadoop    20   0   17.7g   8.6g  27756 S  1.0 27.4   0:10.99 java
15072 hadoop    20   0   17.7g   8.6g  27756 S  1.0 27.4   0:11.04 java
</code></p>

<p>可以发现，14321 14275 这两个线程使用的cpu最多，那么这两个线程对应的算子是什么呢？这里就需要使用到jstack</p>

<p><code>jstack 14142 &gt; flink.dump</code></p>

<p>就可以得到jstack的信息。注意，需要以java进程运行用户的身份来运行上面的命令。</p>

<p>可以得到下面这些东西：</p>

<p>```
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.131-b11 mixed mode):</p>

<p>"Attach Listener" #3673 daemon prio=9 os_prio=0 tid=0x00007f76403d6000 nid=0x676d waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE</p>

<p>"flink-metrics-22" #3672 prio=1 os_prio=0 tid=0x0000000002ef6000 nid=0x674f waiting on condition [0x00007f75bd85d000]
   java.lang.Thread.State: TIMED_WAITING (parking)</p>

<pre><code>    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  &lt;0x00000004406d94d8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
    at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:467)
    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1066)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:748)
</code></pre>

<p>"flink-akka.actor.default-dispatcher-33" #3668 prio=5 os_prio=0 tid=0x00007f765db5f800 nid=0x66d8 waiting on condition [0x00007f75bf67d000]
```</p>

<p>jstack输出的hex也就是16进制的，所以我们需要把pid再做一下转换。使用python可以调用hex方法.</p>

<p>```
Python 3.6.8 (default, Aug  7 2019, 17:28:10)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type "help", "copyright", "credits" or "license" for more information.</p>

<blockquote><blockquote><blockquote><p>hex(14321)
'0x37f1'
hex(14275)
'0x37c3'
```</p></blockquote></blockquote></blockquote>

<p>然后在dump文件中搜索<code>0x37f1</code>，可以得到</p>

<p>```
"at35__process -> (at35_e -> Sink: at35_sink, at35_current_parameter, at35_current_state) (1/1)" #142 prio=5 os_prio=0 tid=0x00007f7648a78800 nid=0x37f1 in Object.wait() [0x00007f75d53d6000]
   java.lang.Thread.State: WAITING (on object monitor)</p>

<pre><code>    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:502)
    at org.apache.flink.runtime.io.network.partition.consumer.UnionInputGate.waitAndGetNextInputGate(UnionInputGate.java:211)
    - locked &lt;0x0000000441ab5ae8&gt; (a java.util.ArrayDeque)
    at org.apache.flink.runtime.io.network.partition.consumer.UnionInputGate.getNextBufferOrEvent(UnionInputGate.java:169)
    at org.apache.flink.streaming.runtime.io.BarrierBuffer.getNextNonBlocked(BarrierBuffer.java:165)
    at org.apache.flink.streaming.runtime.io.StreamTwoInputProcessor.processInput(StreamTwoInputProcessor.java:273)
    at org.apache.flink.streaming.runtime.tasks.TwoInputStreamTask.run(TwoInputStreamTask.java:117)
    at org.apache.flink.streaming.runtime.tasks.StreamTask.invoke(StreamTask.java:300)
    at org.apache.flink.runtime.taskmanager.Task.run(Task.java:711)
    at java.lang.Thread.run(Thread.java:748)
</code></pre>

<p>```</p>

<p>```
"at20_window -> (at20__message, at20_current_parameter, at20_current_state) (1/1)" #112 prio=5 os_prio=0 tid=0x00007f76485f1800 nid=0x37c3 in Object.wait() [0x00007f75d7af9000]
   java.lang.Thread.State: WAITING (on object monitor)</p>

<pre><code>    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:502)
    at org.apache.flink.runtime.io.network.partition.consumer.UnionInputGate.waitAndGetNextInputGate(UnionInputGate.java:211)
    - locked &lt;0x0000000441a00cc8&gt; (a java.util.ArrayDeque)
    at org.apache.flink.runtime.io.network.partition.consumer.UnionInputGate.getNextBufferOrEvent(UnionInputGate.java:169)
    at org.apache.flink.streaming.runtime.io.BarrierBuffer.getNextNonBlocked(BarrierBuffer.java:165)
    at org.apache.flink.streaming.runtime.io.StreamTwoInputProcessor.processInput(StreamTwoInputProcessor.java:273)
    at org.apache.flink.streaming.runtime.tasks.TwoInputStreamTask.run(TwoInputStreamTask.java:117)
    at org.apache.flink.streaming.runtime.tasks.StreamTask.invoke(StreamTask.java:300)
    at org.apache.flink.runtime.taskmanager.Task.run(Task.java:711)
    at java.lang.Thread.run(Thread.java:748)
</code></pre>

<p>```</p>

<p>然后就可以看见线程的名字，就可以去代码里进一步对症下药了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[入手本精装书]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2020/04/13/ru-shou-ben-jing-zhuang-shu/"/>
    <updated>2020-04-13T11:20:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2020/04/13/ru-shou-ben-jing-zhuang-shu</id>
    <content type="html"><![CDATA[<p>最近博客发的有点少，主要是切换回纸质书+纸质笔记本了。
另外，机缘巧合，买了本《Design Patterns》的原版精装，价钱只要200出头，相当的划算。必须承认原版精装书的阅读体验确实很棒。</p>

<p>原版四五百页精装书，放在桌上看的体验真的普通版的给不了。封面和纸张的手感是很不一样的就不说了，关键是精装的书里面有线，书是可以翻平的。这个胶板书真给不了。</p>

<p>不过计算机书籍国内精装版的基本很少，老外的也不多，估计还是大部分计算机图书的生命周期太短了吧。</p>

<p>顺手翻了一下图灵和异步的精装图书。技术类的是不多的，图灵除了著名的计算机编程艺术，也就黑客与画家、阮一峰文集、番茄工作法、写给大家看的设计书等寥寥几本。异步稍微好一点。像重构第二版、深度学习的两本，还有持续交付和一本也是国内人编写的广告计算，合计也就5本。但国内编写的两本，怎么看都更像是方便作者自己送人的。所以在国内还真的享受不了什么看精装技术图书的乐趣。当然，即使国外，如Effective Java都没有出过精装版，那么实际上拥有硬封皮的计算机书籍也是不多的。</p>

<p>顺便在天珑看了一下台湾图书的价格，同时发现现在台湾引入的简体版还真的不少，价格就比较有意思了。举《重构》和《领域驱动设计》两本书为例，价格如下（均为天珑实际售价)</p>

<table>
<thead>
<tr>
<th></th>
<th> 图书版本               </th>
<th> 台币                       </th>
<th> 人民币 </th>
<th> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 重构台湾 </td>
<td> 632 </td>
<td> 148 </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 英文版hard cover </td>
<td> 1995 </td>
<td> 467 </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 精装简体版</td>
<td> 699 </td>
<td> 163 </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 简体平装 </td>
<td> 469 </td>
<td> 107 </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 重构第一版简体 </td>
<td> 327 </td>
<td> 76 </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> </td>
<td>  </td>
<td>  </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 领域驱动设计简体平装 </td>
<td> 393 </td>
<td> 92 </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 领域驱动设计繁体平装 </td>
<td> 530 </td>
<td> 124 </td>
<td> </td>
</tr>
<tr>
<td></td>
<td> 领域驱动设计英文版  </td>
<td> 2470 </td>
<td> 578 </td>
<td> </td>
</tr>
</tbody>
</table>


<p>英版的价钱确实还是很贵的。而在台湾销售的大陆书籍，大约比国内网店普通售价贵了一倍。</p>
]]></content>
  </entry>
  
</feed>
