<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2021-08-19T19:48:22+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apollo Config]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2021/08/19/apollo-config/"/>
    <updated>2021-08-19T17:30:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2021/08/19/apollo-config</id>
    <content type="html"><![CDATA[<p>配置项的管理始终是一个很头疼的问题。虽然磕磕绊绊总能凑合着过，但确实一直不太优雅，甚至容易出错。
人多的情况下，优雅是很难的，还是考虑怎么能减少损耗吧。所以抽空看了看Apollo的东西。</p>

<blockquote><p>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。</p></blockquote>

<p>也支持热更新、版本控制、分组等比较实用的特性，据说还能适应复杂的流程治理要求。简单适用了一下，确实不负盛名。</p>

<h3>一. 安装并启动Apollo</h3>

<p>因为是试用，目前使用的是单机版的Apollo，后续可能会进一步调研一下高可用版的发布。</p>

<p>下载 <code>https://github.com/apolloconfig/apollo-build-scripts.git</code> ,  修改<code>demo.sh</code>里面的数据库配置信息和config server信息:</p>

<pre><code> apollo_config_db_url="jdbc:mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai"
-apollo_config_db_username=root
-apollo_config_db_password=

 # apollo portal db info
 apollo_portal_db_url="jdbc:mysql://localhost:3306/ApolloPortalDB?characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai"
-apollo_portal_db_username=root
-apollo_portal_db_password=

-config_server_url=http://localhost:8080
-admin_server_url=http://localhost:8090
 eureka_service_url=$config_server_url/eureka/
-portal_url=http://localhost:8070
</code></pre>

<p>config server就是未来的meta server，portal就是管理界面。</p>

<h3>二. Java端的配置</h3>

<p>对于基于Sprint Boot的应用而言，最简单和顺利的方式是在bootstrap.yml里面。操作步骤如下</p>

<ol>
<li>加入依赖 <code>   implementation group: 'com.ctrip.framework.apollo', name: 'apollo-client', version: '1.8.0'</code></li>
<li>除去原先对config的依赖 <code>compile('org.springframework.cloud:spring-cloud-starter-config')</code>, 删除整个application.yml文件</li>
<li>删除application.yml文件，并把内容转移到apollo里面</li>
<li>在bootstart.yml里面替换下面的文件</li>
</ol>


<pre><code>apollo:
  bootstrap:
    enabled: true
    namespaces: application,application.yml
  meta: http://xxxx:8080
app:
  id: xxxxxx-compare-monit
</code></pre>

<p>enabled表示启用apollo读取配置，namespaces是给出了需要拉取的namespace，默认只有application一个，如果是自己添加的yml，则需要按上面的配置加一个。
meta就是config server的地址。app.id表示了应用的身份，需要和apollo的对应起来。</p>

<p>如果再portal侧重新发布配置项，可以看见下面的日志</p>

<pre><code>INFO 69947 --- [Apollo-Config-1] c.f.a.s.p.AutoUpdateConfigChangeListener : Auto update apollo changed value successfully, new value: 222222, key: bcmonit.xxxxxKey, beanName: xxxxxxProperties, field: com.xxxxx.address.util.xxxxxProperties.xxxxxKey
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql的库表容量查询]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2021/08/09/mysqlde-ku-biao-rong-liang-cha-xun/"/>
    <updated>2021-08-09T17:52:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2021/08/09/mysqlde-ku-biao-rong-liang-cha-xun</id>
    <content type="html"><![CDATA[<pre><code>select  
table_schema as '数据库',  
table_name as '表名',  
table_rows as '记录数',  
truncate(data_length/1024/1024, 2) as '数据容量(MB)',  
truncate(index_length/1024/1024, 2) as '索引容量(MB)'  
from information_schema.tables  
order by data_length desc, index_length desc; 
</code></pre>

<p>可以查询库里的表名、数据容量和索引容量。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CORS问题]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2021/03/18/corswen-ti/"/>
    <updated>2021-03-18T13:40:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2021/03/18/corswen-ti</id>
    <content type="html"><![CDATA[<p>动手搞了一下Nginx和Chrome的CORS问题，顺手记录一下一些基本概念。</p>

<p>CORS的本意是限制Http请求中Origin的来源，主要是用于保护浏览器客户端的，可以一定程度上防止浏览器访问页面A时，莫名其妙连去B站资源的情况发生。</p>

<p>原理上，CORS工作时会先发出一个OPTIONS请求，并携带Origin消息头：</p>

<pre><code>OPTIONS /
Host: service.example.com
Origin: http://www.example.com
Access-Control-Request-Method: PUT
</code></pre>

<p>然后，服务器端如果支持跨域，则会返回Access-Control-Allow-Origin消息头，里面给出允许访问的Origin域名。如果用<code>*</code>，则表示没有任何限制。如果要允许多个域名，则可以使用Nginx中动态变量的方法，这种情况下每次还是只返回一个域名。</p>

<pre><code>location / {

                root html;
             if ($request_method = "OPTIONS") {
add_header Access-Control-Allow-Origin *;
                add_header 'Access-Control-Allow-Credentials' 'true';
                add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With';
                add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS';
                add_header 'Access-Control-Max-Age' 10;
                return 204;
             }

                add_header 'Access-Control-Allow-Credentials' 'true' always;
                add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With' always;
                add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS' always;
                add_header 'Access-Control-Max-Age' 10 always;
                proxy_set_header host $host;
                proxy_set_header X-real-ip $remote_addr;
                proxy_set_header X-forward-for $proxy_add_x_forwarded_for;
                proxy_pass http://127.0.0.1:8080;
        }
</code></pre>

<p>Nginx的配置需要注意两点：</p>

<ol>
<li>add_header在proxy_pass时默认不会起作用，如果需要起作用，则要加上<code>always</code>参数。</li>
<li>Access-Control-Allow-Origin 要严格的只有1条，不能有多条。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DDD的蓝书和红书]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2021/02/16/dddde-lan-shu-he-hong-shu/"/>
    <updated>2021-02-16T21:37:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2021/02/16/dddde-lan-shu-he-hong-shu</id>
    <content type="html"><![CDATA[<p>跟着Vlad的「Unit Testing Principles, Practices, and Patterns」 学习单元测试的原理实践和模式之后，
一路追踪，自然会发现要写好测试自然会要用到Domain-Driven Design的分析和设计方式。因为要写出容易测试代码，
首先需要写出业务上的好代码，而要做到这一点，目前已知的解法殊途同归，就是要运用DDD的方式，解除业务代码对框架和技术细节的依赖，而专注于业务（领域）本身。加上多年以前DHH推荐的5本他膺服的编程书籍中，就有Eric Evans的「Domain-Driven Design」，也就是蓝皮书。</p>

<p>但这本书确实很不好读。中文版的购于去年3月份，反反复复并看不下去，7月份开始看英文版，废了半年的时间，才断断续续终于看完了。蓝皮书确实写的是不容易褪色和随着时间流逝而跌价的书籍，内里的原则和一些很细节的建议应该只要OO继续是编程的主要范式，那么蓝皮书的价值和地位就会持续存在。比如他评价OO把一切都看成对象，就是等于建筑师把一切都看成房间。过于抽象，其实反而失去了运用时的指导意义。为此，开发出了七种武器来分别描述不同的用于处理业务的OO。</p>

<p>而统一语言，则是强调分析人员、设计人员和最终使用人员使用同一种语言来进行沟通，就像厨房、卫生间、客厅等并非只是建筑师的用语。这样可以用一套原则来进行指导和沟通。DDD本身强调独立性的目的，是通过解除对外部的依赖从而达到可以把核心问题暴露出来并予以解决。从而可以让运维逻辑丰富且清晰，将Domain作为软件的核心，而把APP层做薄。沿着这条路前进了多年之后，随着TDD等实践的进一步发展，获得了易测试等突破性的好处。因此，在国外甚至国内部分项目中，都取得了广泛的应用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mybatis-plus的字段为复杂对象的读取和装载]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2021/01/14/mybatis-plusde-zi-duan-wei-fu-za-dui-xiang-de-du-qu-he-zhuang-zai/"/>
    <updated>2021-01-14T21:19:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2021/01/14/mybatis-plusde-zi-duan-wei-fu-za-dui-xiang-de-du-qu-he-zhuang-zai</id>
    <content type="html"><![CDATA[<p>如果核心代码写的非常OO，那么Entity中自然会出现很多Value Object。一旦这些VO需要存入数据库，则会牵涉到一个数据库字段转换到Java类型的ORM问题。<br/>
比如有下面的代码：</p>

<pre><code class="java">@Data
// @TableName(autoResultMap = true)
public class Validator {
    private Long id;

    // @TableField(typeHandler = CommissionTypeHandler.class)
    private Commission commission;
}

public class Commission {
    final private BigDecimal commission;
}
</code></pre>

<p>Commission作为一个VO，也需要保存到Validator的表格中。Mybatis通过typeHandler的方式来实现这种钩子，完成这种转换。具体做法为先定义相应的handler, 即<code>TypeHandler&lt;T&gt;</code>接口的实现类</p>

<pre><code class="java">import com.walletguard.polkadotprx.entity.Commission;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.MappedJdbcTypes;
import org.apache.ibatis.type.MappedTypes;
import org.apache.ibatis.type.TypeHandler;

import java.math.BigDecimal;
import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

@MappedJdbcTypes(JdbcType.DECIMAL)  //数据库类型
@MappedTypes(Commission.class)
public class CommissionTypeHandler implements TypeHandler&lt;Commission&gt; {

    @Override
    public void setParameter(PreparedStatement ps, int i, Commission parameter, JdbcType jdbcType) throws SQLException {
        ps.setBigDecimal(i, parameter.getCommission());
    }

    @Override
    public Commission getResult(ResultSet rs, String columnName) throws SQLException {
        BigDecimal co = rs.getBigDecimal(columnName);
        return new Commission(co);
    }

    @Override
    public Commission getResult(ResultSet rs, int columnIndex) throws SQLException {
        BigDecimal co = rs.getBigDecimal(columnIndex);
        return new Commission(co);
    }

    @Override
    public Commission getResult(CallableStatement cs, int columnIndex) throws SQLException {
        BigDecimal co = cs.getBigDecimal(columnIndex);
        return new Commission(co);
    }
}
</code></pre>

<p>该接口有4个需要实现的method，其中3个是读取，1个是写入，这里又用到了很传统的JdbcTemplate的方式类设置和读取相应的值，读出后转换成自己需要的对象。
<code>MappedJdbcTypes</code>指明了Jdbc中的类型， <code>MappedTypes</code>指明了OO中的对象类型，也就是接口<code>TypeHandler&lt;T&gt;</code>中的T。</p>

<p>然后，在上面类型的对象中，作<code>@TableField(typeHandler = CommissionTypeHandler.class)</code>声明，即意味着该字段用这个typeHandler来进行处理。<br/>
但是，这只是确保可以写入，如果要支持读取，还需要在Class的开头，加上<code>@TableName(autoResultMap = true)</code>，这样这个ORM就实现了。</p>
]]></content>
  </entry>
  
</feed>
