<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2017-05-21T00:44:15+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[thymeleaf感想]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/05/21/thymeleafgan-xiang/"/>
    <updated>2017-05-21T00:07:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/05/21/thymeleafgan-xiang</id>
    <content type="html"><![CDATA[<p>刚使用spring boot时得知thymeleaf取代了jsp的默认地位，我是有所抵触的，做法就是重新配置回了jsp。
然而随着java web开发前后端业已分离的现实，逐步明白view层是thymeleaf还是jsp已经不再重要。因为java已变成
服务成守候在服务器侧，而原先页面的工作已经完全交给了（不需要会java）的前端人员，且他们是完全可以胜任的。</p>

<p>实际上截至目前，最新版的thymeleaf已经到了3.0以上的版本，而spring boot最新版集成的还是<strong>2.x</strong>的thymeleaf的版本，
可以认为这块已经处于冷淡的状态。</p>

<p>不过，凡是总有例外。这次又碰见了需要产生静态页面的业务场景，其中有不少的业务逻辑，所以还是需要一个view层，考虑到
新团队的习惯，决定采用thymeleaf吧，这样以后维护可以交给前端来做。于是简易学习了一下leaf，感觉还是不错的。</p>

<p>leaf最大的特色就是前端人员可以直接打开leaf所在的html页面，并做到完全的无异物感。脚本、链接完全动态静态可以分开。
这样解决了jsp长期以来美工介入很困难的问题,同时做的又比freemaker等更加到位。内置标签支持的语言语法也很现代化和好用，一般有jsp经验的程序员，
花个半天看一下一百来页的手册并动手实践一下，就完全可上手了。至于<code>jsp</code>，是可以退出历史舞台了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Truffle And Solidity]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/05/01/truffle-and-solidity/"/>
    <updated>2017-05-01T10:11:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/05/01/truffle-and-solidity</id>
    <content type="html"><![CDATA[<p>区块链应用的开发，主要指用<code>Solidity</code>编写合约(Contract)，然后部署到区块链上去。
注意，此处的区块链特指<code>以太坊</code>，而比特币的区块链是没有Solidity这种东西的。</p>

<p>因为是把sol编写的合约部署到区块链上去，所以可以进一步分解为3个问题：</p>

<ol>
<li>区块链的安装(testrpc ethereum)</li>
<li>sol合约编写(Solidity)</li>
<li>对sol合约进行编译以及发布(truffle)</li>
</ol>


<p>目前来看，整个以太坊很喜欢借用node即javascript来构建他们的环境，尽管区块链和sol本身其实和javascript关系不大。
关于ethereum可查相关的安装手册，这里主要记录一下Solidity和truffle。</p>

<p>Sol的编辑器可以用atom vscode等等，submiline也没问题。
这门语言其实还是比较原始的，合约间的调用甚至不能传递结构（struct），更可悲的是返回string也不行。基本上任何不定长的返回
在sol的ethvm（以太坊虚拟机）中都不太好调用。
功能上来讲，solidity可以理解成数据存放在一个类似levelDB的内存数据库，这是ethvm会做的事情。
```javascript</p>

<p>  mapping(uint=>LibDisSecPledgeApply.DisSecPledgeApply)  disSecPledgeApplyMap;</p>

<pre><code>uint[] disSecPledgeApplyIds;
</code></pre>

<p>```</p>

<p>上述代码定义了一个用于存放对象数据的mapping，因为mapping无循环遍历的功能，所以又增加了一个ids的数组保留所有对象的编号。</p>

<p>整个合约的编写，其实对写惯后台程序的人来讲还是不难上手的（类似用java操作redis写业务逻辑），只是限制确实比较多。
但solidity可以支持的变化太少，所以写起来是复杂不到哪里去。相当于成熟的脚本或编译型语言，solidity麻烦的地方在于其调试，
可简单罗列的就有两点：</p>

<ol>
<li>编译速度慢。十几个文件的情况下，用 truffle编译就要3分钟以上</li>
<li>发布调试困难。必须发布到某个链的环境才能测试，而这个就真的很不友好了，断点还不支持，日志也很麻烦。</li>
</ol>


<p>truffle是现在以太坊主要推荐的编写solidity的编译、测试运行和部署工具，能处理较复杂的sol文件关联引用，就是耗时很长，且
程序版本很不稳定，变化发展都依然极快。truffle是基于node和npm的，所以要先装好node。</p>

<p><code>javascript
npm uninstall truffle
npm install -g truffle@2.1.2
truffle compile  //编译合约
truffle migrate --reset //部署合约
truffle exec xxxx.js //执行某个js文件
</code></p>

<p>和区块链一样，solidity，truffle都是刚刚涌现的东西，所以问题很多，用起来也不一定顺手。但，这个行业就是这样的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CA证书略记]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/03/01/cazheng-shu-lue-ji/"/>
    <updated>2017-03-01T19:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/03/01/cazheng-shu-lue-ji</id>
    <content type="html"><![CDATA[<p>CA是Certificate Authority的缩写，就是一个证书颁发机构的意思。
它的作用是给某些公钥证书进行背书，以让调用者相信所获得的公钥证书确实的某个组织给予的。</p>

<p>具体做法可抽象为：<br/>
1. 某个组织自己生成一个公钥/私钥对<br/>
2. 该组织向某CA申请证书，需要把自己的身份信息、公钥交给ca，同时用自己的私钥给以上信息签名形成一个CSR，格式可以说pkcs10等<br/>
3. CA生成证书，比如P7b格式的证书。</p>

<p>此后，该申请的组织就可以把获得的证书交给客户，客户会去CA处验证证书的有效性等。</p>

<p>在现实中，浏览器、手机等默认内建很多知名CA，可能有几百个，对于这些CA颁发的证书均认为是安全的。</p>

<p>上述只是颁发完毕，之后进入使用阶段。</p>

<p>公钥与私钥的理解：
　(1)私钥用来进行解密和签名，是给自己用的。<br/>
　(2)公钥由本人公开，用于加密和验证签名，是给别人用的。<br/>
  (3)当该用户发送文件时，用私钥签名，别人用他给的公钥验证签名，可以保证该信息是由他发送的。当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他接收到。</p>

<h3>数字签名的基本用法</h3>

<p>由于私钥加密东西长度是有限制的，所以一般私钥只用于对内容散列后的签名。
比如<code>SHA1withRSA</code>，顾名思义就是SHA1散列后用rsa加密散列值。</p>

<p>公钥端收到后，可对散列值进行解密，解密后再和收到的数据进行散列操作后的结果进行比对，如果散列值一致，那么该签名就是有效的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ICE初探]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/02/28/icechu-tan/"/>
    <updated>2017-02-28T17:46:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/02/28/icechu-tan</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[区块链功课]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/02/02/qu-kuai-lian-gong-ke/"/>
    <updated>2017-02-02T13:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/02/02/qu-kuai-lian-gong-ke</id>
    <content type="html"><![CDATA[<p>https://www.igvita.com/2014/05/05/minimum-viable-block-chain/</p>

<p>Google的工程师讲解的P2P去中心化现金交易的底层技术---区块链（Block Chain），然后发现区块链的一大基石
是公钥私钥的加密技术，所以作者拿出了经典的Alice Bob来作为举例。</p>

<h2>中心化的支付技术</h2>

<p>目前的支付系统流行的是triple-entry 记账方式。三联为Alice Bob 和Chuck（中心节点，比如银行）都记录着交易记录，
以保证交易的可靠性和非重复性。
这套系统运作的前提是大家都信任Chuck。</p>

<h2>去中心化的难点</h2>

<h3>1. 一致性问题</h3>

<p>去中心化后，系统变成了分布式的，而分布式在一致性方面先天弱于中心化的。处理<strong>Double-spending</strong>的问题是一个难点。
因为一个交易发生后，系统中的其他参与者往往并不知道已经发生，可能还认为Bob拥有大量的钱财。在一个小的系统里，
可以通过全部完成通知后才认可交易成功，而这对一个大规模系统基本不可行。CAP理论表明P2P系统很难支持强一致性，但是，区块链技术
的亮点在于实现了weak(er) consistency。</p>

<h3>2. Sybil attacks （西比尔攻击）</h3>

<p>该攻击的特色在于虚拟出许多虚假的交易者，让真实的交易者误以为消费已经坐实。解决办法是增加造假的成本，同时保持验证的
成本够低，通过经济杠杆来从结构上阻止有人愿意造假，因为得不偿失就是傻事了。</p>

<p>但这带来的一个问题就是单个交易成本会很高，如果交易的手续费高于交易本身，那么这套系统也是没法运行的。</p>

<h3>Block的概念</h3>

<p>Block就是一组交易的集合，不单如此每个Block还记录了前一个Block，从而构成了Block Chain区块链。
每个交易者都可以将有效的交易集合生成一个block，生成block需要耗费大量的计算资源。
而将验证成本集中成Block的好处就是降低了每笔交易的成本，或者说交易集合共同承担了手续成本。而对交易有效性的、一致性、Sybil attacks的
防范都基于Block来进行。</p>

<h3>Block Chain的冲突</h3>

<p>因为所有的参与者都可以生成Block，所以一笔交易可能会加入在多个Block里。此时就构成了冲突，出现了chain fork。Block Chain对此的解决方式很简单粗暴，
永远选择最长的那个chain fork作为“真实的”交易链，并丢弃之前的交易分支。</p>

<p>使用的技术都是现成的：</p>

<ul>
<li>accounting</li>
<li>cryptography</li>
<li>networking</li>
<li>proof-of-work</li>
</ul>


<p>然而集合起来就又构成了一个新的精巧的方案。</p>
]]></content>
  </entry>
  
</feed>
