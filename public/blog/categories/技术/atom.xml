<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: 技术 | Hegel2011的博客]]></title>
  <link href="http://octopresszhangyu.herokuapp.com/blog/categories/技术/atom.xml" rel="self"/>
  <link href="http://octopresszhangyu.herokuapp.com/"/>
  <updated>2017-03-01T19:20:37+08:00</updated>
  <id>http://octopresszhangyu.herokuapp.com/</id>
  <author>
    <name><![CDATA[Hegel 2011]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CA证书略记]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/03/01/cazheng-shu-lue-ji/"/>
    <updated>2017-03-01T19:08:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/03/01/cazheng-shu-lue-ji</id>
    <content type="html"><![CDATA[<p>CA是Certificate Authority的缩写，就是一个证书颁发机构的意思。
它的作用是给某些公钥证书进行背书，以让调用者相信所获得的公钥证书确实的某个组织给予的。</p>

<p>具体做法可抽象为：<br/>
1. 某个组织自己生成一个公钥/私钥对<br/>
2. 该组织向某CA申请证书，需要把自己的身份信息、公钥交给ca，同时用自己的私钥给以上信息签名形成一个CSR，格式可以说pkcs10等<br/>
3. CA生成证书，比如P7b格式的证书。</p>

<p>此后，该申请的组织就可以把获得的证书交给客户，客户会去CA处验证证书的有效性等。</p>

<p>在现实中，浏览器、手机等默认内建很多知名CA，可能有几百个，对于这些CA颁发的证书均认为是安全的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ICE初探]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/02/28/icechu-tan/"/>
    <updated>2017-02-28T17:46:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/02/28/icechu-tan</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[区块链功课]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/02/02/qu-kuai-lian-gong-ke/"/>
    <updated>2017-02-02T13:55:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/02/02/qu-kuai-lian-gong-ke</id>
    <content type="html"><![CDATA[<p>https://www.igvita.com/2014/05/05/minimum-viable-block-chain/</p>

<p>Google的工程师讲解的P2P去中心化现金交易的底层技术---区块链（Block Chain），然后发现区块链的一大基石
是公钥私钥的加密技术，所以作者拿出了经典的Alice Bob来作为举例。</p>

<h2>中心化的支付技术</h2>

<p>目前的支付系统流行的是triple-entry 记账方式。三联为Alice Bob 和Chuck（中心节点，比如银行）都记录着交易记录，
以保证交易的可靠性和非重复性。
这套系统运作的前提是大家都信任Chuck。</p>

<h2>去中心化的难点</h2>

<h3>1. 一致性问题</h3>

<p>去中心化后，系统变成了分布式的，而分布式在一致性方面先天弱于中心化的。处理<strong>Double-spending</strong>的问题是一个难点。
因为一个交易发生后，系统中的其他参与者往往并不知道已经发生，可能还认为Bob拥有大量的钱财。在一个小的系统里，
可以通过全部完成通知后才认可交易成功，而这对一个大规模系统基本不可行。CAP理论表明P2P系统很难支持强一致性，但是，区块链技术
的亮点在于实现了weak(er) consistency。</p>

<h3>2. Sybil attacks （西比尔攻击）</h3>

<p>该攻击的特色在于虚拟出许多虚假的交易者，让真实的交易者误以为消费已经坐实。解决办法是增加造假的成本，同时保持验证的
成本够低，通过经济杠杆来从结构上阻止有人愿意造假，因为得不偿失就是傻事了。</p>

<p>但这带来的一个问题就是单个交易成本会很高，如果交易的手续费高于交易本身，那么这套系统也是没法运行的。</p>

<h3>Block的概念</h3>

<p>Block就是一组交易的集合，不单如此每个Block还记录了前一个Block，从而构成了Block Chain区块链。
每个交易者都可以将有效的交易集合生成一个block，生成block需要耗费大量的计算资源。
而将验证成本集中成Block的好处就是降低了每笔交易的成本，或者说交易集合共同承担了手续成本。而对交易有效性的、一致性、Sybil attacks的
防范都基于Block来进行。</p>

<h3>Block Chain的冲突</h3>

<p>因为所有的参与者都可以生成Block，所以一笔交易可能会加入在多个Block里。此时就构成了冲突，出现了chain fork。Block Chain对此的解决方式很简单粗暴，
永远选择最长的那个chain fork作为“真实的”交易链，并丢弃之前的交易分支。</p>

<p>使用的技术都是现成的：</p>

<ul>
<li>accounting</li>
<li>cryptography</li>
<li>networking</li>
<li>proof-of-work</li>
</ul>


<p>然而集合起来就又构成了一个新的精巧的方案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[zookeeper]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2017/01/15/zookeeper/"/>
    <updated>2017-01-15T10:27:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2017/01/15/zookeeper</id>
    <content type="html"><![CDATA[<p>用于协作的服务，提供目录树的结构。基本可以认为是Yahoo出品。</p>

<p>data registers - called znodes, file
parlance - directory</p>

<p>数据全部保存在内存中。</p>

<p>优势：
1. 性能好，可在大规模的分布式系统里使用
2. 可靠性高，可防止单点故障
3. 严格的顺序性，可满足复杂的、高精的客户端同步实现要求</p>

<p>znode的读写有acl控制以及版本号</p>

<p>leader nodes负责接受写的请求，follower nodes负责被同步和读取</p>

<p>配置示例</p>

<p><code>
tickTime=2000
dataDir=/var/lib/zookeeper
clientPort=2181
initLimit=5
syncLimit=2
server.1=zoo1:2888:3888
server.2=zoo2:2888:3888
server.3=zoo3:2888:3888
</code></p>

<p>tickTime是一个即使单元，单位是毫秒，2000表示2秒。<br/>
dataDir是存放数据文件的物理位置。<br/>
initLimit表示n个tickTime，上面这个就是10秒的意思，表示连接上leader nodes需要的时间单元数量。<br/>
syncLimit表示山离皇帝能有多远过期<br/>
server.1中的1的服务器内部的<code>myid</code>，zoo1是服务器地址，第二个port即2888用于follewer连接leader，
第三更port 3888用于选举leader。</p>

<p>基本上，zookeeper可以理解成一个分布式系统里，用于进程间通信的中间件，所以剩下的就是客户端调用了。
项目本身提供了C和Java的binding，具体实现时每个客户端会分为IO线程和watch线程两个。而Netflix在此基础上，
构造了wrapper: <code>curator</code>，以方便开发。</p>

<p>首先，引入maven依赖:</p>

<p>```
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;  
&lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;  
&lt;version&gt;3.2.1&lt;/version&gt;  
</code></pre>

<p></dependency>
```</p>

<p>然后，在代码中可如下调用：</p>

<p>```java
package zookeepertest;</p>

<p>import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;</p>

<p>public class CuratorTest {</p>

<pre><code>public void set() {
    String zookeeperConnectionString="127.0.0.1:2181";
    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
            CuratorFramework client = CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);


            client.start();

            try {
                client.create().forPath("/my", "555".getBytes());

                client.getData().forPath("/my");
                Thread.sleep(1000);

                client.setData().forPath("/my", "666".getBytes());

            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
}

public static void main(String[] args) {
    CuratorTest test = new CuratorTest();
    test.set();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>这种调用方式是比较原始的进程间通信，以此为基础，recipes已经实现了一系列通信的高级语意，
如lock、semaphore、确认leader等，可以直接使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx 通过Lua输出response body]]></title>
    <link href="http://octopresszhangyu.herokuapp.com/blog/2016/08/25/nginx-tong-guo-luashu-chu-response-body/"/>
    <updated>2016-08-25T23:03:00+08:00</updated>
    <id>http://octopresszhangyu.herokuapp.com/blog/2016/08/25/nginx-tong-guo-luashu-chu-response-body</id>
    <content type="html"><![CDATA[<p>Nginx默认是不只支持<code>$request_body</code> 而不支持response的body输出的。这个设定是合理的，因为大量的html响应或者静态文件的内容输出将使得整个日志毫无意义。
然而，response body输出对api的请求来讲，则很多时候、尤其是在调试的时候是很有必要的。取代了抓包的作用，且简单直观许多。
搜寻之下，发现使用lua的话，可以达到此目的。</p>

<ol>
<li>下载并安装lua语言的安装包</li>
</ol>


<p><code>
 wget http://luajit.org/download/LuaJIT-2.0.3.tar.gz
tar -zxvf LuaJIT-2.0.3.tar.gz
cd LuaJIT-2.0.3.tar.gz
make &amp;&amp; make install
</code>
注意，可能你的服务器的wget会实际下载一个html到本地导致tar解压失败，此时可以用浏览器下载完毕后再次上传到服务器上。</p>

<ol>
<li>下载并解压ngx_devel_kit套件</li>
</ol>


<p><code>
wget https://github.com/simpl/ngx_devel_kit/archive/v0.2.19.tar.gz
tar v0.2.19
</code></p>

<ol>
<li>下载并解压lua-nginx-module模块</li>
</ol>


<p><code>
wget https://github.com/chaoslawful/lua-nginx-module/archive/v0.9.6.tar.gz
tar v0.9.6
</code></p>

<ol>
<li>下载并解压nginx后，使用下面的命令重新编译nginx</li>
</ol>


<p>```
./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_flv_module --with-http_gzip_static_module --with-pcre --sbin-path=/usr/sbin/nginx --add-module=/root/lua-nginx-module-0.9.6 --add-module=/root/ngx_devel_kit-0.2.19
make &amp;&amp; make install
cp /usr/sbin/nginx /usr/local/nginx/sbin/</p>

<p>```</p>

<p>最后，在nginx的conf文件中的<code>server{}</code>上下文里加入下面代码</p>

<p>```
log_format  main_with_response  '$remote_addr - $remote_user [$time_local] "$request" '</p>

<pre><code>                  '$status $body_bytes_sent "$http_referer" '
                  '"$http_user_agent" "$http_x_forwarded_for"'
                  'request: "$request_body"' 'response: $resp_body';
</code></pre>

<p>server {</p>

<p>...
   lua_need_request_body on;</p>

<pre><code>set $resp_body "";
body_filter_by_lua '
    local resp_body = string.sub(ngx.arg[1], 1, 1000)
    ngx.ctx.buffered = (ngx.ctx.buffered or "") .. resp_body
    if ngx.arg[2] then
         ngx.var.resp_body = ngx.ctx.buffered
    end
';

   location /xxxx {
        root   html;
        access_log  logs/access.log  main_with_response;
        proxy_pass http://192.168.203.198:8080;
    }
</code></pre>

<p>}
```</p>

<p>为避免response溢出整个日志，可选择在特定的location中使用输出response body。</p>
]]></content>
  </entry>
  
</feed>
