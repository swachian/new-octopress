
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Hegel2011的博客</title>
  <meta name="author" content="Hegel 2011">

  
  <meta name="description" content="因为要在一台Linux系统中虚拟化一个系统，于是这周接触了一下Linux下虚拟机的内容。
公司以前一直用的redhat的linux，我所知的虚拟技术仅限于xen和kvm，而且根据一些反馈用的并不是很好。主要体现在资源占用过大，硬盘和内存的消耗都很大，当然公司的服务器硬件配置也有点不够平衡。 然而， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://octopresszhangyu.herokuapp.com/blog/page/5/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Hegel2011的博客" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Hegel2011的博客</a></h1>
  
    <h2>读书 - 工作 - 生活 - 笔记</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:octopresszhangyu.herokuapp.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">关于自己</a></li>
  <li><a href="/blog/2014/03/02/to-read-list/">To-Read</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/17/linuxxia-de-xu-ni-hua-ji-zhu/">Linux下的虚拟化技术</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-17T20:59:00+08:00" pubdate data-updated="true">Aug 17<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>因为要在一台Linux系统中虚拟化一个系统，于是这周接触了一下Linux下虚拟机的内容。<br/>
公司以前一直用的redhat的linux，我所知的虚拟技术仅限于xen和kvm，而且根据一些反馈用的并不是很好。主要体现在资源占用过大，硬盘和内存的消耗都很大，当然公司的服务器硬件配置也有点不够平衡。</p>

<p>然而，在接触了ubuntu的虚拟化后，一下子有茅塞顿开的感觉。首先，windows下我常用的virtualbox就可以在ubuntu下使用。xen和kvm当然ubuntu也是支持的。同时这几种虚拟化技术都可以按命令行的方式使用。其次，ubuntu在安装虚拟化套件方面是十分方便的。主要原因在于它的包要比redhat的时新的多。还有一点，ubuntu比起redhat还是很小巧的。这点在虚拟化的时候显得比较重要。毕竟一台主机的时候，只会安装一个os，如果大2GB那也就只是2GB。一旦云化后，一台主机往往就要4+1个操作系统，在磁盘不富裕的情况下，os的臃肿会成比例的放大。这时候小巧的os就显示出了优势。<br/>
所以我倾向于采用ubuntu server作为云化的主力os。至少应该是虚机的主体。</p>

<p>接下来就是选择何种东西虚拟化了。主要下面3种：</p>

<ul>
<li>xen: 国内用的最多，因为历史最长，也有商业化的支持</li>
<li>kvm：半虚拟化技术，做在kernel里面，redhat和ubuntu大力支持</li>
<li>virtualbox: 是的，其实这可能是最好用的linux虚机软件</li>
</ul>


<p>性能方面，根据<a href="http://www.liangsuilong.info/?p=675">kvm vs Virtualbox</a> 和 <a href="http://server.zol.com.cn/257/2575328.html">Ubuntu11.10 Xen Kvm Virtualbox比拼</a>，总体而言kvm的性能最佳，大文件比virtualbox有所不如。而且从未来规划来看，redhat和ubuntu普遍倾向于支持kvm。但是，virtualbox有两大优势：1.使用是图形化的界面，很简单； 2.与kvm和xen都专注于cpu性能不同，virtualbox的图形化性能要比另外两个都强许多。不过vbox实际上是基于qemu改进的，kvm-qemu也是一个组合。所以，普通用用的情况下可以直接上virtualbox。</p>

<p>顺手又了解了一些vnc的内容。vnc其实只是一个传送图形界面的协议，经典的client和server端模型，但具体的GUI还需要由其他东西实现。可选的有<code>xfce4</code>和<code>ubuntu-desktop</code>，前者小巧不少大约200MB，后者如果是server上安装则要1GB以上了。总体而言不如ssh方便，占用资源也多不少，不过在必须使用图形化界面的时候，都还是不错的选择。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/26/web-and-html-document/">Web and HTML Document</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-26T09:07:00+08:00" pubdate data-updated="true">Jul 26<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>DHH在2013年的rails conf上做了关于类37signals web应用发展方向的报告。听了之后，还是解除了很大的迷茫。</p>

<p>工作十余年，开发Web应用也八九年了。期间研究过Flex，也写过不少ajax。但到今天却觉得Web的form提交然后出结果才是真正最有用的。
我们的下单，填填表格，登录等等，讲到底需要的只是一个让人知道怎么填的form，然后简单的提交就足够了。其余的东西再花哨，很多时候对解决问题并没有实质性的帮助。<br/>
然而，富客户端应用也是客观存在的，甚至有js重度客户端应用将取代HTML应用的论调甚嚣尘上。以我的感觉判断，这是不太会发生的。原因在于js的开发很麻烦，工作量其实是很大的，而且也限制死了可以使用的工具。要取得一个简单的页面所达到的效果，完全采用js会产生巨大的工作量。而Web应用至今而且也将继续是大量表单类的应用。只要客户端的开发难度、工作量依然如此同服务端不成比例，那么就很难成为主流，更别提替换HTML了。<br/>
所以，在这一点上毫无疑问我赞同D大神的，重客户端应用不可能取代Web HTML应用。</p>

<p>DHH陈述的突破之处在于提出这种HTML应用为 <strong>document-based</strong> Web ，以同google 地图这种应用区分开来。Web由于其简单或者说简陋，想要丰富它或者取代它的技术一直没中断过。从Java Applet开始，到flash，Siverlight等等，都曾经让Web的效果不堪一击。然而，20年来的现实情况是，不拥抱Document的技术最终都在HTML之前走了下坡路。D大神把从90年代中期至今的挑战HTML技术串联起来说，体现了磅礴的气势和全面的大局观。</p>

<p>与此同时，他也认为Document需要继续发展，这就是他说的再Basecamp，其实也就是Rails4中增加的新技术，其实本质就是caching。具体包括：</p>

<ul>
<li>key-based cache (generational caching)</li>
<li>Russian Doll nested caching, 4 level, touch: true, partial md5</li>
<li>Turbolinks process persistence, (pajx)</li>
<li>Polling for js updates(类似rjs)</li>
</ul>


<p>核心内容就是提高HTML在浏览器上的速度。而Caching能大规模流行的基础是<strong>内存红利</strong>.</p>

<table>
<tr><td>  2003年  </td><td>  512MB </td><td>  $49  </td></tr>
<tr><td>  2013年  </td><td>  8GB   </td><td>  $29  </td></tr>
</table>


<p>不过此次Web面临的挑战和多年来历次遇到的还是有很大不同的。不管是flash还是applet，他们都是想作为整体的HTML+CSS+Javascript发起挑战。而这次却是原来Web整体中的Javascript和HTML谁唱主角之争。区别在于JS和HTML所占比例及所显示页面数量的巨大区别。</p>

<p>但是，只要Web还够简单，只要js的开发工作量还很繁重，那么产生HTML依然还是主要的Web应用模式。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/12/centos5-ruby2-dot-0-and-rails4-dot-0/">CentOS5 Ruby2.0 and Rails4.0</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-12T12:55:00+08:00" pubdate data-updated="true">Jul 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>升级了一个很小的rails应用到4.0，原先使用的版本ree1.8.7 + rails3.1 。因为应用很小，也没使用很多插件，所以git checkout一个branch之后，用rails new生成新的目录完全替换掉老的文件。然后用<code>git diff</code>对一个一个目录或者文件进行比对与合并。整个过程下来，发现rails默认生成的文件，3.1和4.0的区别并非很大。</p>

<p>这个过程也就是只有几个小时，半天不到的时间就让应用可以跑起来了。本地测试了一下，写入数据库、查询、写入文件等都没什么问题。随后自然就是部署。</p>

<p>但此时，问题来了. 本地开发的环境是这样的：</p>

<ul>
<li>Ubuntu 12.04</li>
<li>gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5)</li>
<li>ruby 2.0.0p195 (2013-05-14 revision 40734) [x86_64-linux]</li>
<li>rails 4</li>
</ul>


<p>而部署环境是这样的：</p>

<ul>
<li>CentOS release 5.4</li>
<li>gcc 版本 4.1.2 20080704</li>
<li>ruby 2.0.0p247 (2013-06-27) [i686-linux]</li>
<li>rails 4</li>
</ul>


<p>在本地运作良好的rails4应用，部署到生产环境后发生下面两个异常：</p>

<p>1 <code>rake db:migrate</code>每次只能成功一个migrate，但经反复执行后，能够migrate完整</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SQLite3::SQLException: SQL logic error or missing database: INSERT INTO "schema_migrations" ("version") VALUES (?)</span></code></pre></td></tr></table></div></figure>


<p>2 开发环境下正常，生产环境下会报告<code>nil?</code>在某个object上不存在。</p>

<p>为此，则折腾掉了很多的业余时间。</p>

<p>怀疑过是Gem的版本问题，怀疑过是ruby版本的问题,也怀疑过是ruby编译问题。</p>

<p>针对第一种可能，重新生成了一个rails应用，执行的结果照旧。<br/>
为了第二种可能，使用了ruby2.0.0p195，异常依旧；换成ruby1.9.3，但发现有个atom的gem都不能bundle上去。<br/>
随后，针对第三个可能，不惜<strong>升级的了CentOS到5.9</strong>(<code>yum upgrade</code>),为此下载了600MB的更新包。 <br/>
又重新编译安装了ruby2.0.0p0, 哦?!，世界太平了。虽然第一个异常依然，但第二个异常没了，应用是能够跑的起来了。
之后，再重新编译另外两个ruby版本就都可以正常工作了（第一个问题还是在的）。</p>

<p>由此可见，这是一个和gcc版本、os版本及ruby版本都相关的bug。</p>

<h3>教训</h3>

<p>新版的ruby或Rails同CentOS接触的并不好，如果要少麻烦的话，APP的OS还是应该选择Ubuntu。从生态的情况来看，这个责任只能怨CentOS支持的内核、gcc、lib库都过于老旧了。<br/>
之所以这么说，不单单是因为在ruby上碰到这种要比在ubuntu上麻烦的多的情形。从七周七语言的情况看，CentOS即使是CentOS6，也不支持对Haskell的安装，在安装其他语言时，多多少少都会遇到编译麻烦的问题。<br/>
CentOS是基于Redhat的，以稳定（老旧）为荣。而APP则是迅速发展的，因此二者极其容易脱节。所以，APP服务器首选Ubuntu。</p>

<h3>题外话</h3>

<p>从对OS的依赖少这点来看，Java确实做了件很漂亮的事情。一个编译好的jdk文件，可以在几乎全部的主流linux下解压，然后即可使用。部署时也不用担心底层OS是什么实现。所以，如果是Java的应用，继续用CentOS也是不会有很多坑的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/09/clojure-is-really-pesky/">Clojure Is Really Pesky</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-09T22:07:00+08:00" pubdate data-updated="true">Jul 9<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最早知道clojure，是在Heroku宣布<a href="https://blog.heroku.com/archives/2011/7/5/clojure_on_heroku">支持</a><a href="http://devcenter.heroku.com/articles/clojure">它</a>，这是Heroku支持的第三种语言。知道彼时这个东西挺火。应该和闭包什么的有关联。</p>

<p>这次看七周七语言，终于得以一睹真容。知道了clojure其实就是Lisp的一个JVM实现。
不过今天试用了一下clojure，感觉这个东西不太灵。
基于JVM的设计思路听上去不错，但仔细想想JVM的lib真有那么大的意义吗？答案是否定的。我不太相信用惯了其他语言的人会喜欢在新语言中继续调用java的内容。在ruby中，我不会有兴趣去调用java。一旦用惯了clojure也不太可能再接受调用java的api。对比起来，scala倒是和java结合的挺紧密。</p>

<p>变成jvm的一部分，一大恶果就是启动变慢，从而作为脚本功能来跑很不美。毕竟一个jvm启动的时间很长，内存消耗也很大，对于处理任务极其简单的情况下，jvm启动的时间和内存开销显然过大了。
其次，融入jvm中，意味着需要ide的配合。无论哪种ide，都是很重的，因此很是麻烦。
叠加起来，就是导致这种基于jvm模式的开发是不令人愉快的。</p>

<p>而Lisp程序员似乎都喜欢用emacs，emacs和ide兼容，呵呵，这是在开什么玩笑。注定这东西的推广在开发层面会存在很大的障碍。</p>

<p>当然，天下英雄用java做clojure scala甚至jruby也不是没原因的。Jvm的性能确实很好，底层的库也很齐全，安装clojure也比较方便，但clojure又引入了leinxxx。不过Java的开发效率毕竟比C高，基于java开发新的语言大概也容易一些。另外就是需要连接数据库等组件都是现成的。这就使得在java上涌现出了很多二次开发的语言。可能，这才是那么多Java实现的根本原因。</p>

<p>但是，个人不太看好就因为用java实现，这些新语言就会被java开发的主流程接纳。道理很简单，混在jvm里面只是有利于复用已有jvm的机器（这点其实也不太重要），好歹部署还算方便，然而对开发而言完全是另学一套，而同时加上的枷锁和限制却更多了。</p>

<p>真的要给java注入活力，最直接了当的办法是让java中调用ruby clojure等，而且是要方便地调用。   伟大语言才会诞生伟大的框架和lib，而现在这种只解决新语言中调用java lib，其实是不利于java王者归来的。只是这条路这些年已经无人深入了。</p>

<p>除了和JVM跳舞令人哭笑不得外，Clojure自身的语法也很难让人爱。基本就是Lisp那套，写啥都已左右括号为主，这样的感觉其实是不太棒的。特别好这口的人除外。这个不是通过教育就能改变的。</p>

<p>所以看了一圈clojure的内容后，觉得这个语言目前还是浅尝辄止为好。</p>

<p>最后，需要提一下的是，这个语言的性能也比较普通。比普通脚本语言快，但比JS V8慢。相较于Scala Haskell，Clojure还是弱了一些。 <br/>
<img src="/images/screen_print/programming_performance.jpg" alt="image" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/16/prolog/">Prolog</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-16T22:46:00+08:00" pubdate data-updated="true">Jun 16<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>七周七语言看完了Ruby，又继续看了Io，这是一个prototype的语言，确实和js很像，也挺有启发。不过决定还是
好好去学javascript吧。其实<a href="http://www.w3school.com.cn/js/index.asp">w3school</a>的这份js教程很棒，
相当言简意赅。入门是最重要的。入门之后才能走的更远。很多时候究竟有多远看的还是基础，但没有摸起来，那
基本功就无从发挥了。</p>

<p>随后看了<a href="http://www.gprolog.org">Prolog</a>，其实是<strong>gprolog</strong>。
这个语言跟我过去学习的语言都很不一样。完全抛弃了过程语言所拥有的能力，全部都集中在了逻辑判断上。实际上其组成结构是这样的：</p>

<ul>
<li>事实。就是自己先设定一些前提，指定一些事实，比如<code>likes(wallace, cheese).</code></li>
<li>规则。规则就是关于一些事实的推论。比如<code>friend(X, Y) :- \+(X = Y), likes(X, Z), likes(Y, Z).</code>，这个规则由3个条件构成，

<ul>
<li>第一个是X！=Y</li>
<li>第二个和第三个是X和Y都喜欢Z，然后他们就符合friend这条规则</li>
</ul>
</li>
<li>查询。查询就是使用时给出问题，然后让prolog根据规则库（<strong>事实</strong>+<strong>规则</strong>）循环访问得出结果或判断出结果。</li>
</ul>


<p>本质上，应该是用过程语言写了一系列的判断和分析语句（<strong>引擎</strong>）,这样使用时使得编码行为就完全不一样了。</p>

<h3>最大的启发</h3>

<p>最大的启发在于，这一门应该算是我首次学的不是过程式的编程语言。当然，前提是HTML和CSS不能算编程语言。其他的，如C、C++、Java、Ruby、Python、Javascript乃至shell等，虽然有的是纯过程式的，有的是面向对象的，但实际上都<strong>包含了过程式</strong> 的风格。</p>

<h3>试用体验</h3>

<p>还是有点别扭的。它的语法确实很古老，而且很不顺手，这点和<code>erlang</code>有的一拼。
不过确实是只要树立规则，就能输出结果。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/14/the-orgnization-of-an-app-site/">一个App站点的人员组织</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-14T15:08:00+08:00" pubdate data-updated="true">Jun 14<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>参考了一下残游记的组织与分工，小结如下：</p>

<ul>
<li><p>产品经理，1，老板</p></li>
<li><p>后端开发，1, 技术负责人</p></li>
<li><p>前端，1，解决浏览器兼容等问题, 也可以转app开发，总之就是UI工程师</p></li>
<li><p>视觉设计师，2</p></li>
<li><p>ios开发，1，</p></li>
<li><p>运营，2，应该就是管理员和推销员</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/12/my-first-gem/">My First Gem</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-12T17:02:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天终于尝试做了第一个<code>gem</code>，其实挺简单的，至少在有了bundler之后。</p>

<p>先 <code>bundle gem act_as_xxx</code>，随后就可以编辑里面的内容，比如在<code>*.gemspec</code>里面加入描述。编辑好自己的gem后，运行<code>gem build act_as_xxx.gemspec</code>，这样一个新的gem就会编译出来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Successfully built RubyGem
</span><span class='line'>  Name: act_as_xxx
</span><span class='line'>  Version: 0.1.1
</span><span class='line'>  File: act_as_xxx-0.1.1.gem</span></code></pre></td></tr></table></div></figure>


<p>最后<code>gem push act_as_xxx-0.1.1.gem</code> 就发布到rubygems.org上面了。</p>

<p>基本的流程是走通了，不过怎么怎么测试怎么调试等还需要进一步摸索。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/06/7dbs-in-7wks/">7dbs in 7wks</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-06T05:59:00+08:00" pubdate data-updated="true">Jun 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>花了2个礼拜的时间，看完了七天七数据库。这是又一本在kindle上看完的epub格式的书籍。阅读体验的效果还是很不错的。</p>

<p>书籍受了七天七语言的启发，整本书的胶水语言主要是用了ruby，也伴随使用了一些javascript。作者对redis做了特别多的介绍，HBase等的描述也很精彩。Neo4J对我而言还属新生事物。</p>

<p>这本书区别于其他数据库图书的价值就在于比较与分析，呵呵，话说这个和我的撰文风格挺类似的。</p>

<p>首先，从RDBMS(PostgreSQL)开始，描述了SQL设计时的世界是查询的弹性要求远大于结构的弹性。回想一下，彼时的数据库查询都是由开发人员或者公司信息科的人来完成的，也就是直接使用SQL。而在如今，操作人员全部通过界面，可能是Web也可能是client，SQL都是后台自己拼接而成，于是SQL最强悍的地方其实已经打了折扣。而业务上，甚至统计方面，经常会对schema参数剧烈变化的要求。还有很重要的一点，就是关系型数据库是大家思想统一的东西，沟通方便。<br/>
关系型数据库最大的优势在于acid的操作支持，以及运行多年而证明的稳定可靠。但在大规模访问和灵活性方面确实存在缺陷。</p>

<p>然后，介绍了面向列的数据库。其实面向列就是存放是按照一列一列内容来存放的，有版本和时间戳的自动功能，适合于存放大数据。甚至还有压缩的功能。作者把HBase比喻为钉子气枪（nail gun)。他的每个查询都不快，但最强大之处在于<strong>遍历巨量数据集合</strong>。<br/>
所以常常被大公司用了作为日志和搜索系统。<br/>
column里面存放的是map。<br/>
journaling = write-ahead logging.</p>

<p>Riak是一个key-value数据库，不过更适合存放S3D那样的存放二进制的内容。基于Erlang编写。
N, W, R, N是最终数据需要分发到的节点数量，W是写入多少就可以认为写入成功，R则是读取多少就认为读取成功。</p>

<p>也谈到了这些数据库中实现Map-Reduce的哲学是把算法分发给各个节点，而不是把数据集中起来送给算法。毕竟传输算法肯定比传输数据的开销要少。</p>

<p>MongoDB则是在关系型和扩展性强的数据库中取到了一个黄金百分点。可以存放复杂的对象是文档数据库最大的优势。CouchDB不如MongoDB灵活，采用视图查询法（事先定义map-reduce），</p>

<p>最后，则主要还是介绍redis，及混合的多数据库应用开发。内建的可以让key失效，以及丰富的数据结构数据库，是redis脱颖而出的法宝。使得极其适合作为缓存使用。</p>

<p>小结，过去人们依赖一个数据库来实现多个应用的整合。现在整合的能力更多地交给了中间层模式，往往多种语言都是基于HTTP实现服务层之间的通信的。这样就使得服务程序从db的限制中解脱了出来，变得可以根据需要选用多种数据库组合。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/05/cong-cong-ban-nian/">匆匆半年</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-05T23:10:00+08:00" pubdate data-updated="true">Jun 5<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>不知不觉，宝宝出生和研究生毕业都已经快半年了。这半年里书是读了不少，事情也做了一些，突破性的的东西还是没有什么。也抽空去做了一个手术。总而言之，辛苦又忙碌的半年吧。</p>

<p>有了宝宝以后，自己的时间少了，晚上好睡的日子也少了，不过看着宝宝健康成长，那么这一切还是很有意义的。</p>

<p>说句实话，这半年过的还不错。只是飙升的体重真的要想办法调整才行了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/05/qian-duan-dao-di-zhong-yao-bu-zhong-yao/">前端到底重要不重要</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-05T21:32:00+08:00" pubdate data-updated="true">Jun 5<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近发现淘宝的前端大牛似乎想往后端发展，摆脱只做前端的印象；<br/>
另一方面, teahour上的人却认为越来越多的工作从服务器往前端在靠，投入在javascript上面的工作量和时间越来越多。单用围城效应这个不是太能解释的通。</p>

<p>以我个人这段时间的开发经验来看，前端很多事情和很细小，消耗的时间确实很多。比较起来，在这方面花费太多的时间如果能移到后端的话，确实可以完成更多的事情。从Get Things Done的角度而言，前端的意义是不如后端的。毕竟无论界面多么花哨，真正值得关注的还是内容。就像我们去淘宝，不是因为界面有多炫，而是里面的商品价格等吸引着我们。</p>

<p>然而，事情又不那么简单。首先，世上的事情一定要Get Done的讲穿了也不多，如果只盯着最有意义的事情，那么只有长生不老，而这个完成不了的话其实做任何事情最后都是徒劳的。因此，忽视前端的效果是不对的。   其次，前端可以吸引眼球，也和少挨骂有重要相关的作用。虽然吸引我上淘宝的不是其界面，但如果他的界面很傻，那么作为用户还是会骂的。当然，比起完事界面确实是次要的。就像我能忍受12306的界面，只要他能让我订完票能兑现就一切ok。<br/>
还有一点，没有好的前端，服务根本吸引不了人。毕竟大部分人也不会有什么杀手级的内容，这个时候比拼界面反而是能反应团队的水平及做事用心的程度。</p>

<p>所以，我的结论是，如果后端和内容有足够重要的事情，那么还是围绕后端。反之，有余力后可关注前端。毕竟门面功夫也不可小觑。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/6/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/4/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/09/xin-che-ping-de-%5B%3F%5D-xie-shu-ju/">新车评的一些数据</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/01/xin-che-ping-de-sui-xiang/">新车评网的随想</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/23/kao-pu-de-you-hao-shu-ju-ku/">靠谱的油耗数据库</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/23/le-fu-de-de-guo-dui-zhong-yu-you-guan-liao/">勒夫的德国队终于有冠了</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/23/pro-javascript-techniques/">被低估的JS： 「Pro JavaScript Techniques」读后感</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/技术'>技术 (48)</a></li><li><a href='/blog/categories/生活'>生活 (33)</a></li><li><a href='/blog/categories/读书笔记'>读书笔记 (21)</a></li><li><a href='/blog/categories/神器'>神器 (19)</a></li><li><a href='/blog/categories/时评'>时评 (19)</a></li><li><a href='/blog/categories/笔记'>笔记 (18)</a></li><li><a href='/blog/categories/车车'>车车 (14)</a></li><li><a href='/blog/categories/ruby'>Ruby (11)</a></li><li><a href='/blog/categories/rails'>Rails (10)</a></li><li><a href='/blog/categories/linux'>Linux (9)</a></li><li><a href='/blog/categories/软考'>软考 (8)</a></li><li><a href='/blog/categories/项目管理'>项目管理 (8)</a></li><li><a href='/blog/categories/云计算'>云计算 (6)</a></li><li><a href='/blog/categories/nodejs'>Nodejs (5)</a></li><li><a href='/blog/categories/nosql数据库'>Nosql数据库 (5)</a></li><li><a href='/blog/categories/heroku'>Heroku (4)</a></li><li><a href='/blog/categories/java'>Java (3)</a></li><li><a href='/blog/categories/script'>Script (3)</a></li><li><a href='/blog/categories/旅游'>旅游 (3)</a></li><li><a href='/blog/categories/期刊'>期刊 (2)</a></li><li><a href='/blog/categories/spring'>Spring (2)</a></li><li><a href='/blog/categories/sass'>Sass (2)</a></li><li><a href='/blog/categories/外刊'>外刊 (2)</a></li><li><a href='/blog/categories/svn'>Svn (1)</a></li><li><a href='/blog/categories/测试'>测试 (1)</a></li><li><a href='/blog/categories/网络编程'>网络编程 (1)</a></li><li><a href='/blog/categories/安装'>安装 (1)</a></li><li><a href='/blog/categories/git'>Git (1)</a></li><li><a href='/blog/categories/装机'>装机 (1)</a></li></ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Hegel 2011 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Web Statistics" href="http://getclicky.com/66623321"><img alt="Web Statistics" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
  <script src="//static.getclicky.com/js" type="text/javascript"></script>
  <script type="text/javascript">try{ clicky.init(66623321); }catch(e){}</script>
  <noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/66623321ns.gif" /></p></noscript>

</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
