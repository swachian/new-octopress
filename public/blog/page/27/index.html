
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Hegel2011的博客</title>
  <meta name="author" content="Hegel 2011">

  
  <meta name="description" content="外刊班是丁老师自己的理想。虽然效果很大，买账的学生并不多。毕竟大部分学生的认识能力有限，强求不得的。所有的视频班都是网上播放，唯外刊有光盘刻，也是老丁在坚持自己的理想，自己的快乐。 四期是08年冬天的寒假（“视频拍摄费用很高，三个小时就一两千，希望以后有机会”），但实际上应该是拍了 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://swachian.github.io//blog/page/27/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Hegel2011的博客" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Hegel2011的博客</a></h1>
  
    <h2>读书 - 工作 - 生活 - 笔记</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:swachian.github.io/" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">关于自己</a></li>
  <li><a href="/blog/2015/02/20/to-read-list/">To-Read</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/09/15/waikanban-diandi/">外刊班点滴</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-09-15T18:48:00+08:00" pubdate data-updated="true">Sep 15<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>外刊班是丁老师自己的理想。虽然效果很大，买账的学生并不多。毕竟大部分学生的认识能力有限，强求不得的。所有的视频班都是网上播放，唯外刊有光盘刻，也是老丁在坚持自己的理想，自己的快乐。</p>

<p>四期是08年冬天的寒假（“视频拍摄费用很高，三个小时就一两千，希望以后有机会”），但实际上应该是拍了</p>

<p>三期讲了三十篇文章 07年夏天 无视频</p>

<p>07年寒假第二期 无视频</p>

<p>06年暑假第一期 无视频</p>

<p>09年寒假第五期（石头，于超，这个外刊视频班纯粹是不赚钱，甚至是亏本在做，比去年多了光盘包）.背景是有一排tank的房间。</p>

<p>09年暑假第六期 无视频</p>

<p>10年寒假第七期</p>

<p>11年寒假第八期</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/09/08/superinterior/">半天读完细节营销</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-09-08T18:48:00+08:00" pubdate data-updated="true">Sep 8<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>不曾想只花了半天时间就读完了这本书。一方面这本书确实很薄，只有32k、200来页。另一方面，行文很易懂，说的也很有道理，而且与我的理念基本吻合，所以接受起来相当迅速。</p>

<p>但还需要消化消化。营销是又一个一个分解后的内容组成的，每个组成部分就是一个细节。不能出现太明显的短板。比如1x1x1x0.1x1x1=0.1</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/09/07/read-market/">外刊超精读学习进展</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-09-07T18:48:00+08:00" pubdate data-updated="true">Sep 7<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>从7.10开始学习外刊，用了50天时间，到8.28看完了第五期光盘。随后开始进行总结，目前总结了1/3.在学习的过程中，已经感觉到了很大的进步，尤其在输入这块。对段间的衔接，段内各意群的衔接，阅读时的耐心及预测和回推等，学了不少招数。</p>

<p>今天，借着试看2006年英语的超精解，做了一遍2006年的真题。阅读四篇一小时多一点时间错了3个。学外刊之前，10年的英语二四篇错了5个，11年的英语二四篇错4个。而据说06年的真题属于偏难。由此看来，我的英语水平在这2个月期间已获得很大进步。终于入门了。</p>

<p>&#8212; update on 2012.01.13
随后学习了第八期光盘。这期看的比较琐碎，而且放弃了之前第五期的复习。所以长进不大。在做12年英语一的时候，还是错了三四个。当然英语二只错了2个，而且今年的文章比前两年的难一些，说明读外刊后的进步还是很大的。
此外，听力依旧是老大难的问题，要想办法予以解决。</p>

<p>&#8212; update on 2013.01.06
英语似乎上不去了，做考研英语连续几年都是错4道，外刊也一直在看，但就是没有更明显的成长。当然我也明白，考研英语还是很难的，4个以内的错误要再有进步本身就不容易。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/29/sass/">Sass</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-08-29T18:48:00+08:00" pubdate data-updated="true">Aug 29<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><a href="http://sass-lang.com/tutorial.html">sass</a></li>
<li><a href="http://railscasts.com/episodes/268-sass-basics">rails cast</a></li>
</ul>


<p>sass的几大特性</p>

<ul>
<li>nest</li>
<li>variable</li>
<li>function</li>
<li>mixin,variable</li>
</ul>


<p>另外还有files的组织</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/30/review-of-biograph-for-wjl/">读《吴敬琏传》</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-30T18:48:00+08:00" pubdate data-updated="true">Jul 30<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>吴敬琏是一个中国公共知识分子，以他的市场化经济闻名于当代，最近则日益呼唤法治的市场经济。我所读的这本书正是以他为主人公，由另一名知名的经济作家吴晓波编写。该传从吴的家庭背景和青年时代说起，接着是研究所、文革下放的经历，以及在这段日子中他说接触的前辈、学友，到形成自己对经济制度的认识，留学耶鲁回国后开始成为中央的think tank，尤其是90年代后成为江朱进行市场化经济体制改革的重要理论及方针提供者，进而影响着我们这个国家和社会。03年之后，随着政府的换届，吴也逐步从决策层淡出。此时的他思想也随之有所改变，淡出的因素既有人际关系的问题，更有着深层次的利益冲突的问题。</p>

<p>纵观全书，最有价值的是最后几章，因为问题直指当前的状况，并且也道出了很多失策以及背后运作的原理，而这些又是最紧急的要处理要辨识的。4万亿的实质是什么，会把我们带向何方？出口型的经济必然导致货币通胀以及内需不振。因为货物留出去了，留在自己的只有钱。钱多物少，又如何不通胀？唯一的替代品就是资产价格暴涨，资产主要就是股票、房地产等。而所谓的深化体制改革，基本也只能是空话。意识形态不是根深蒂固的，但是中国人、中国政府、暴君与暴民却是中国固有的，要替换这些东西谈何容易。放弃苏联人那套简单，放弃中国人心中的尾巴就难了，何况有些东西绝不仅仅是思想尾巴那么简单，实际的利益摆在那边，基本无解。</p>

<p>次一级有意思的地方是书的前半段，尤其是吴的出生背景及他的母亲。出生于知识分子家庭，母亲是一个成功的报业企业家，其家族也是有名民营企业家，甚至还参与过铁路的建设，作为资方。包括吴和其太太周南认识的场景、几十年的相濡以沫，都令人十分感动。吴生活的家族是一个伟大的家族。</p>

<p>接下来的描述是本书的主体。但对于读过中国经济改革教程的人来说，这部分就变成了一个很好的背景知识的补充。一些在阅读教程时想了解的东西，比如耶鲁的生活，顾准、sunyefang的介绍更加丰满，毕竟有些东西也不太好在教程里自己直接描述。甚至包括了他如何同中央进行交流等。这些东西合在一起，使得对一个公共知识分子如何发挥作用、影响中国的变革，有了鲜活的了解。</p>

<p>要评价吴敬琏，必须说他所倡导的东西好坏并存，成功与失败并举。这个就不再展开。</p>

<p>得到的另一个结论是，中国的通胀不可避免，冬天早就该到，只是人为的延后了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/07/new-service-offered-by-heroku-nodejs/">Heroku的新服务</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-07T18:48:00+08:00" pubdate data-updated="true">Jul 7<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Heroku发表了一系列介绍自己内部升级的文章。最重要的变化是开始支持除ruby/rack以外的语言和框架。起先加入了node.js，然后又加入了Clojure. Clojure是跑在jvm上面的一种语言，对这块没研究。</p>

<p>在heroku看来，ruby的高动态性和强调美感使她天生适合面向用户的web应用。Node.js的基于事件的搞并发使得它适合实时web。 Clojure使得需要correctness,performance,composability, optionally的组件成为可能，并且触及java的生态圈。</p>

<p>heroku开始支持Java. <a href="http://blog.heroku.com/archives/2011/8/25/java/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+heroku+%28Heroku+News%29">heroku for java</a>
不支持war包比较让人痛苦。试着发布一个应用玩玩吧。</p>

<p>Real apps come from real developers Real developers wanted to use their own tools</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/28/display-git-branch-in-shell/">给shell加上显示git的分支</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-06-28T18:48:00+08:00" pubdate data-updated="true">Jun 28<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><code>
function find_git_branch {
    local dir=. head
    until [ "$dir" -ef / ]; do
        if [ -f "$dir/.git/HEAD" ]; then
            head=$(&lt; "$dir/.git/HEAD")
            if [[ $head == ref:\ refs/heads/* ]]; then</p>

<pre><code>        head=$(&lt; "$dir/.git/HEAD")
        if [[ $head == ref:\ refs/heads/* ]]; then
            git_branch=" (${head#*/*/})"
        elif [[ $head != '' ]]; then
            git_branch=' (detached)'
        else
            git_branch=' (unknown)'
        fi
        return
    fi
    dir="../$dir"
done
git_branch=''
</code></pre>

<p>}
PROMPT_COMMAND=&#8221;find_git_branch; $PROMPT_COMMAND&#8221;
green=$&#8217;\e[1;32m&#8217;
magenta=$&#8217;\e[1;35m&#8217;
normal_colours=$&#8217;\e[m&#8217;</p>

<p>PS1=&#8221;[$green]\u@\h:\w[$magenta]\$git_branch[$green]\$[$normal_colours] &#8221;
</code>
秘密在于PROMPT_COMMAND，以保证每次都会执行以下find_git_branch函数</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/25/notes-of-ihower-rails/">Ihower Rails的学习记录</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-06-25T18:48:00+08:00" pubdate data-updated="true">Jun 25<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>HTML use syntax: true</p>

<p>Rails 命令</p>

<pre><code>rails s(erver) thin
rails new app
rails g(enerate) model/controller/resouce/migration
rails dbconsole #打开数据库的console
rails destroy #和generate对应
</code></pre>

<p>一些启动参数，位于application 和各目录下面</p>

<pre><code>config.cache_classes = false 对应load
config.cache_classes = true 对应require
#其实挺简单的东西，当你了解语言特性的话
config.action_mailer.perform_deliveries = false 是否会寄信
</code></pre>

<p>路由</p>

<pre><code>match '/events', :to =&gt; "events#index", :via =&gt; :get, :as =&gt; "events"
match '/events', :to =&gt; "events#create", :via =&gt; :post, :as =&gt; "events"
#增加 :as可以提供events_path这样的helper
</code></pre>

<p>action_name cookies header params session 等在controllers中都是方法</p>

<p>几种controller内的render</p>

<pre><code>* render :text =&gt; "Hello" 直接回傳字串內容，不使用任何樣板。
* render :xml =&gt; @event.to_xml 回傳XML格式
* render :json =&gt; @event.to_json 回傳JSON格式(再加上:callback就會是JSONP)
* render :nothing =&gt; true 空空如也

* :template 指定Template
* :action 指定使用該Action的Template(注意到只是使用它的Template，而不會執行該Action內的程式)
* :file 指定Template的檔名全名

#其他参数
* :status 設定HTTP status，預設是200，也就是正常。其他常用代碼包括401權限不足、404找不到頁面、500伺服器錯誤等。
* :layout 可以指定這個Action的Layout，設成false即關掉Layout
</code></pre>

<p>render_to_string :partial => &#8220;foobar&#8221;
    * redirect_to :action => &#8220;show&#8221;, :id => @event
    * redirect_to :back 回到上一頁。
</pre></p>

<p>flash的新老写法</p>

<pre>
flash[:notice]
flash.now[:notice]
</pre>


<p>rescue_from可以在Controller中宣告救回例外, :show_found是对应的例外执行方法</p>

<pre>
resuce_from ActiveRecord::RecordNotFound, :wtih => :show_found
</pre>


<h3>ActiveRecord中的多对多关联</h3>

<p>這個Join table筆者的命名習慣會是ship結尾，用以凸顯它的關聯性質。另外，除了定義Foreign Keys之外，你也可以自由定義一些額外的欄位，例如記錄是哪位使用者建立關聯。</p>

<p>has_and_belongs_to_many方法也可以建立多對多關係，但已很少使用</p>

<pre>
has_many  ：models ，:through =>model_ships用的更多
ModelShip.create(:m1=>m1, :m2=>m2)很有意思
</pre>


<p>自定义validate方法，注意礼貌的错误添加手法</p>

<pre>
validate :my_validation

private

def my_validation
    if name =~ /foo/
        errors[:name] << "can not be foo"
    elsif name =~ /bar/
        errors[:name] << "can not be bar"
    elsif name == 'xxx'
        errors[:base] << "can not be xxx"
      end
end
</pre>


<p>可以在before_validation中要求增加缺省值，改回调在before_save前</p>

<pre>
before_validation :setup_default
</pre>


<p>請避免before_開頭的回呼方法中，最後運算的結果不小心回傳false。這樣會中斷儲存程序。如果不確定的話，請回傳return true。
而在其他回调方法中，是不是false则无所谓</p>

<p>新老数据的获取及比对</p>

<pre>
person.changed?       # => true 有改變
person.name_changed?  # => true 這個屬性有改變
person.name_was       # => 'Uncle Bob' 改變之前的值
person.name_change    # => ['Uncle Bob', 'Bob']
</pre>


<h3>layout及ActionView</h3>

<p>使用字串和symbol效果不同，前者直接定义模板名称，后者表明执行一个函数</p>

<pre>
layout "special", :except => [:show, :edit, :new]
layout :determine_layout
</pre>


<p>因為Helper預設只能在Template中使用，如果想在rails console中呼叫，必須加上helper，例如<pre>helper.link_to</pre>。另外，雖然機會不多，如果真的要在Rails Controller或Model程式中呼叫Helper，則可以加上ApplicationController.helpers前置詞。</p>

<p>格式化輔助方法</p>

<pre>
    * javascript_include_tag
    * stylesheet_link_tag
    * image_tag
    * video_tag
    * audio_tag
</pre>


<p>video<em>*和audio</em>*是新增加的</p>

<p>几个文本处理方法，textilize被移出3.0</p>

<pre>
    * simple_format 將\n換行字元換成HTML的<br>標籤
    * truncate 擷取前n個字元
    * sanitize 白名單逸出
    * strip_tags 移除HTML標籤
    * strip_links 移除HTML超連結標籤
</pre>


<p>URL輔助方法</p>

<pre>
    * link_to 文字超連結
    * mail_to E-mail
    * button_to 按鈕連結
</pre>


<p>自定標籤輔助方法 ?</p>

<pre><code>* tag
* content_tag
</code></pre>

<p>其他輔助方法</p>

<pre>
    * escape_javascript
    * debug
    * number_to_currency
</pre>


<p>在Rails 2版本中有error_messages_for和error_message_on方法，Rails 3則被移成Plugin http://github.com/rails/dynamic_form，实际上用ryan的直接写在application_helper中也行</p>

<p>如果採用Sass的話，推薦還可以採用Compass(http://compass-style.org/)這套CSS框架的框架。</p>

<p>生产环境下，还是需要rake assets:precompile来在public/assets目录下产生css文件</p>

<pre>
rake assets:precompile #要求pipeline产生文件
</pre>


<p>3种新的远程(ajax)调用写法</p>

<pre>
<%=link_to “say hello”, { :controller => “welcome”, :action => “say” }, :id => “ajax-load”, :remote => true, “data-type” => “html”%> #替换整个html，相当于replace_html情形
</pre>


<pre>
#执行js脚本
<%= link_to 'ajax show', event_path(event), :remote => true, "data-type" => "script" %>
js.erb
$('#content').html("<%= escape_javascript(render :partial => 'event') %>")
             .css({ backgroundColor: '#ffff99' });
</pre>




<pre>
#返回json对象
<%= link_to 'ajax show', event_path(event), :remote => true, "data-type" => "json" %>
</pre>


<p>i18n的中文素材文件
https://github.com/svenfuchs/rails-i18n/tree/master/rails/locale/
資料庫裡面的時間一定都是儲存 UTC 時間?</p>

<p>避免category是nil时报出异常的优良写法</p>

<pre>
Event里面
delegate :name, :to => :category, :prefix => true, :allow_nil => true
@event.category_name
</pre>


<p>产生带namespace的resources</p>

<pre>
rails g controller admin::events
</pre>


<p>rspec测试的高手写法</p>

<pre>
describe Order do
  subject { Order.new(:status=>"New")}
  it(:status) {should == "new" }
end
</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/24/notes-of-r4r/">R4R笔记</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-06-24T18:48:00+08:00" pubdate data-updated="true">Jun 24<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>HTML use syntax: true</p>

<h1>第1章</h1>

<pre><code>ruby -cw c2f.rb
#只进行语法等的检查，-w可以列出详细信息

ruby -rname 是引入指定的扩展，如ruby -rdebug -rprofile
</code></pre>

<p>将一个大文件拆成多个单独的文件是有好处的，通过require可以自行另一个rb文件的代码，load则是反复执行，Rails下的development模式正式用load取代require来达到不用重启，也能执行被更新的文件</p>

<p>erb是ruby的一个重要工具，它是一个程序，可以执行诸如 erb erbdemo.rb 这样的rb程序</p>

<h1>第2章</h1>

<p>第一个开发阶段，定义下面动作</p>

<blockquote><p>用一个现有作品的所有作曲者的列表欢迎访问者</p>

<p>允许访问者点击任一作曲者的名字，然后显示该作曲者的所有作品</p>

<p>允许访问者点击作品的名字，然后显示该作品的所有版本</p>

<p>允许访问者点击任一版本，然后显示该版本的详细信息</p></blockquote>

<p>定义了4个控制器动作，那么就有4个视图需要设计
默认路由即空URL</p>

<p>rails分发器大致是这么工作的</p>

<pre><code>分析url，带出对应的controller和method
填写session和params等信息
调用controller的method
把instance变量写入view的预定义变量中
调用erb程序产生html  
扩展layout
返回html
</code></pre>

<h1>第3章</h1>

<p>交互的、数据库驱动的Web应用是Rails的特定领域。
在rails中编程和配置是融为一体的。yaml就是典型的案例。</p>

<p>Yaml.load
to_yaml
<code>
    def all
      @order = params[:order] || "number"
      sort_proc = case @order
        when "author" then lambda {|r| [r.user.name.downcase, r.number]}
        when "status",
             "title" then lambda {|r| [r.send(@order).downcase, r.number]}
        when "number" then lambda {|r| -r.name}
    end
</code></p>

<p>上面代码中的亮点（feature）是case,lambda,send(最易status和title的处理方式）,sort_by传递一个lambda表达式</p>

<pre><code>def nice_name
  title + " " + first_name + " " +
  if middle_initial then middle_initial + "." else "" end +
  last_name
end
</code></pre>

<p>体会其中的if写入一行的用法。这个代码也体现了通过ruby来扩展rails。</p>

<h1>第4章 对象</h1>

<p>对象： Object.new 对象是程序员的代理</p>

<p>定义对象行为 def obj.talk; puts &#8216;ddd&#8217; ; end</p>

<p>发送消息： object.message</p>

<p>接受参数</p>

<p>返回值</p>

<p> object_id
 respond_to?
 send</p>

<pre><code>if ticket.respond_to?(request)
  puts ticket.send(request)
else
  puts "no such method available"
end
</code></pre>

<p>必须参数，可选参数，默认值参数</p>

<p>局部变量的范围（scope）和赋值（传引用而不是值）</p>

<p>裸辞:
  局部变量
  关键字
  方法调用</p>

<h1>第5章 类</h1>

<p>Ruby是以对象为中心的，而Java是以类为中心的。
在Ruby中，类是组织对象的手段而已，以便不必给每个对象都添加方法。而类本身也是对象。 Ticket.new是一种用工厂方法产生对象的手法。但类通常用常量命名。
    class Ticket
    end
可以认为用class定义了一个常量。
特点：
1. 实例方法与单例方法
2. 重新定义方法（后来者居上）
3. 类可重新打开（在不同的文件中比如）</p>

<p>实例变量：
实例变量表明了类的状态，是和一个对象相关的信息和数据。以@开头，仅对该对象可见，实例变量在一个类中的方法中的定义和引用是同一个. 即@变量属于object这个closure。
在对象初始化时，可在new中传入参数，以生成实例变量，方法是定义<code>initialize</code>函数</p>

<p>对外型的关注是ruby和rails常见的做法，如方法名中的等号实现类似赋值操作，syntactic sugar，语法糖衣</p>

<p>attr_* , attr_reader, attr_writer, attr_accessor, attr只能对一个属性进行操作，不太常用</p>

<p>类是可以生成对象的对象
类也是对象，所以有类方法。即消息发送给类对象本身，而不是类对象的实例。与所有实例都相关，不能由单个实例对象完成。类还有自己的状态和身份标识。类方法的本质就是一个单例方法（添加到单个对象上的方法），其实ruby并没有对class做扩充。</p>

<p>类也来自他的类，即Class类，是Class类的实例</p>

<pre><code>my_class = Class.new
instance = my_class.new
</code></pre>

<p>常量的基本用法是，在靠近类定义的顶部定义，在内部可直接应用，在外部使用双冒号引用 <code>Ticket::VENUES</code>,常量以大写字母开头。
常量的重新赋值会警告，而改变则不会。因为赋值修改的是符号本身，改变改的则是引用的内容。例如常量是一个数组的情况， Helpers=[]，rails里有多处Helper &lt;&lt;　url_helper,用于保存辅助方法名。</p>

<p>继承，祖先（父类和模块），是关键的组织技术之一。祖先和类将它们的实例方法赋予类创建的实例。
ruby中，继承树并不是对象行为的唯一决定者；Object类位于继承树的顶部。</p>

<h1>第6章 模块 module</h1>

<p>Class类是Module的子类，Object是继承树上顶级的类，Kernel是最顶级的模块。
Module与class最大的区别在于没有new方法，不能实例化对象。
Module也是常量。</p>

<pre><code>module MyModule
  def say_hello
     puts "Hello"
  end
end

class ModuleTester
  include MyModule
end

ModuleTester.new.say_hello
</code></pre>

<p>module可以被多个类混合，实现了在多个类间共享代码，同时也提供了更精细的组织代码的方式，在继承之外。include后，可以像使用父类的方法一样使用模块。
模块也能有实例变量。</p>

<p>在对象中寻找方法
1.我是D类的实例，D定义了这个method吗？
2. 没有。D混合了模块了吗？
3. 没有。父类C定义了实例方法吗？
4. 没有。C混合模块了吗？
5. 是的，模块M。M定义了report方法吗？
6. 是的！那么执行该方法。</p>

<p>顶端的是Object, 它include了module Kernel.
给定一个名字，类和模块中仅有一个对应的方法。找到第一个方法就返回，也是后来（定义）者居上的模式。</p>

<p>super可以调用上一个同名匹配。
    super 原封不动传参数
    super() 不传参数
    super(a,b,c) 传指定参数，其实二和三是一种形式。</p>

<p>一般将实体定义为class，而实体的特性定义为module.如Stack  &amp; Stacklike</p>

<p>模块和类可以互相嵌套，一反面提供了命名空间以隔离同名的类，另一方面给规划程序的设计和结构提供了另一维度。
    module Tools
      class Hammer</p>

<pre><code>h = Tools::Hammer.new
</code></pre>

<p>Rails中大量使用了模块化来组织代码，也大量使用了重新打开类。</p>

<h1>第7章 作用域和self</h1>

<p>作用域表明变量以及其他元素的可见性（即内存空间）。self是一个对象，self在程序中可不断改变，可以指向不同的对象。这两个东西决定了在Ruby中的方位感。</p>

<p>4种上下文：
1.顶层(main) 2. 类定义 3.模块定义 4.方法定义（又含顶层、类、模块和单例方法（类方法、模块方法））</p>

<p>class module def 3个关键字出现后会切换到新的self</p>

<p>类方法是一种单例方法，即属于类的方法. 单例方法中的self即单例本身
<code>
obj = Object.new
def obj.show_me
  p self
end
obj.show_me</p>

<p>class C
  def C.x
    p self
  end
end
C.x</p>

<p>class C
  def self.x
    p self
  end
end
C.x
</code></p>

<p>self的主要特权是作为消息的默认接收者.
同时，任何实例变量都属于该位置的self对象。这也意味着任何地方都可以定义实例变量。
理解Ruby中任何地方都有这样一样当前对象，以及判断谁是self。</p>

<p>全局变量，$开头，以及很多内建的全局变量。$$包含进程号，$0执行文件名，$:搜索文件的路径，一般不推荐自定义全局变量。</p>

<p>局部作用域，也是顶层、类或模块（含嵌套的）、方法定义，即class, module, def</p>

<p>常量作用域， ::</p>

<p>私有方法指那些不能指定接收者的方法，因为不能带self，所以作者把这部分内容写在了这边。</p>

<pre><code>private :pour_flour, :add_egg, :stir_batter
</code></pre>

<h1>第8章 控制流技术</h1>

<ul>
<li>条件执行</li>
<li>循环</li>
<li>迭代 block
可能因为block会导致代码执行权（流）的变化，于是加入控制流中</li>
<li>异常</li>
</ul>


<p><code>
if cond1
end</p>

<p>if cond1 then puts x end # 可以把if语句写在一行里，变种是用分号或者冒号替换then</p>

<p>else elsif</p>

<p>每个if后面必有一个end对应，主要用来消除歧义性（else属于哪个if）。举了C的嵌套的例子。
条件修饰语可以不用end 也能写在一行里面</p>

<p>unless</p>

<p>case var
when cond1,cond2
  action
else
end
使用对象的===三等号操作符来进行比较，可自定义这种method的含义。
</code></p>

<p>loop中传入了特殊类型的参数，代码块（code block）。用 {} 或者do和end编写。</p>

<p>loop while until for</p>

<p>yield使得控制转移，执行结束后控制转回。
代码块接收参数的定义方式采用管道||表示法，而非括号(), 但是yield的时候依然是括号，如yield(10).
代码块的返回值如同方法。
本质上因为迭代的需要，以实现<em>方法和代码块之间分工</em>。</p>

<p>raise,
这个是抛出RuntimeError的异常
    raise ArgumentError, &#8220;I need a number under 10&#8221; unless x &lt; 10</p>

<p>resue语句有两种写法：
1. 将想要保护的代码用begin/end包围起来；
2. 要保护一个完整的方法，只要将rescue语句放在定义体的最后。</p>

<pre><code>rescue Errno::ENOENT =&gt; e
#=&gt;构造将异常对象放入变量e中
</code></pre>

<p>创建异常类
<code>
class MyNewException &lt; Exception
end</p>

<p>raise MyNewException, "some new kind of error has occurred!"
</code></p>

<h1>第9章 内建类和模块基础知识</h1>

<h3>字面构造器</h3>

<p><code>
String 引号
Symbol 前导冒号， :symbol 或 :"symbol with spaces"
Array 中括号
Hash 大括号
Range 两个点或三个点
Regexp 斜杠 /([a-z]+)/</p>

<p></code></p>

<h3>语法糖衣</h3>

<p>算数操作符，读写添加数据的方法（[]、[]=、&lt;&lt;)，比较操作符，三等号， +=， 可以像运算符操作那样调用这些方法，这些方法也都能够重载</p>

<p>改变接收对象状态的方法(!)，to_*的方法，迭代器也有返回值（each，collect)</p>

<p>true，false，nil。 nil和false是仅有的两个布尔值为假的对象。表达式为假的则有很多:100&lt;50.</p>

<h3>比较两个对象，牵涉到布尔值及其测试</h3>

<p>== eql? equal? , 通常equal?不会被重新定义，其他两个用于重载。</p>

<p>比较与Comparable模块，只要实现&lt;=>(太空船操作符)，就可使用include Comparable，获得==、&lt;、>等一堆方法。
<code>
class Bid
  include Comparable</p>

<p>  def &lt;=>(other_bid)
    if self.estimate &lt; other_bid.estimate
      -1
    elsif self.estimate > other_bid.estimate
      1
    else
      0
    end
  end
end
</code>
由层叠的if/elsif/else构成，总是返回-1,0,1，分别表示小于、等于、大于。</p>

<p>true.methods.sort.select {|m| m=~/to/}</p>

<h1>第10章 标量对象（无法再分的对象）</h1>

<h3>字符串</h3>

<p>单引，双引，%q(单引)，&amp;Q（双引），单引不支持内插机制。</p>

<p>+， &lt;&lt;（会改变接收者）</p>

<p>symbol, 数值， 时间</p>

<h1>第11章 向量对象（集合对象）</h1>

<p><code>
Array.new(3, "abc")
与
Array.new(3) {"abc"} 的区别。
尤其要注意里面闭包的概念
</code></p>

<p>unshift,push, &lt;&lt;, shift, pop</p>

<p>concat, push, +(不会改变数组本身), replace, zip
[1,2,3].zip([4,5,6]) => [[1,4],[2,5],[3,6]]</p>

<p>flatten(把数组的数组扁平化），reverse，join，uniq， 这些都是直接的、单步的、预定义的改变。</p>

<p>each, each_with_index，</p>

<p>数组过滤操作：find, find_all/select, reject(拒绝符合条件的对象，返回不满足条件的对象)</p>

<p>数组查找操作：size, empty?, include?(item), any?, all?</p>

<p>散列可以使用多个键值来获得多个值，values_at</p>

<p>当找不到key时，可以触发hash把值写入到散列中。</p>

<pre><code>h = Hash.new {|hash, key| hash[key] = key *3}
</code></pre>

<p>merge， merge! / update</p>

<p>invert, clear, replace</p>

<p>迭代: each {|key,value|}, h.keys, h.values, h.each_key {|k|}, h.each_value {|v| }</p>

<p>过滤，返回的都是数组， select, find, map/collcect</p>

<p>查找，has_key?  has_value?, empty?, size</p>

<p>Enumerable和each，each是这个模块的引擎。Comparable和&lt;=>，太空船是这个模块的引擎。
<code>
def each
  yield "red"
  yield "orange"
end</p>

<p>or</p>

<p>def each
  XXX.each {|x| yield x}
end
</code>
调用each的过程中，会把代码执行权返回给find/select，以及自己提供给find/select的代码块。</p>

<p>集合排序
给对象的类定义&lt;=>方法，并把这个类放到某个容器中。</p>

<p>或者，直接在sort {|a，b|} 后面提供代码块，sort_by {|a|}是一种更简洁的方式</p>

<h1>第12章 正则表达式</h1>

<p>String#scan, split, sub, gsub, sub后面可跟代码块，代码块中可用$1等</p>

<p>Enumerable#grep</p>

<h1>第13章 Ruby 动态特性</h1>

<h3>单例类</h3>

<p>单例类是定义单例方法的地方。每一个对象实际上有两个类：
* 多个实例共享的类
* 单例类</p>

<p>单例类中的方法仅属于该对象，可以通过打开单例类来定义单例方法，如同过去常见的def obj.twice; &#8230;; end 一样。
使用的记法是
<code>
class &lt;&lt; object 从而打开了object的单例类,object在此可以是任何对象</p>

<p>使用class &lt;&lt; 可定义类方法.</p>

<p>class Ticket
  class &lt;&lt; self
    def m....
     # etc</p>

<p>上面的例子中，等价于
class &lt;&lt; Ticket
然而其本质都是 class &lt;&lt; object
</code></p>

<p>有了单例类后，查找method的顺序
<code>
  class Object ---> module Kernel</p>

<p>  所属类 --->所属类类include的模块
   |
   |
单例类 --->单例类include的模块 --->单例类的父单例类（如果继承了其他类的话）
</code></p>

<p>说明的链接(&#8220;http://www.iteye.com/topic/1022621&#8221;)</p>

<p>单例类中混含模块的方式有两个，打开单例类和使用extend
<code>
obj = C.new
class &lt;&lt; obj
  include M
end</p>

<p>obj.extend(M)
</code></p>

<p>一个module可以混含在不同层级的类里头，甚至module还可以include module。
通过使用ancestor方法可以打印了解层级结构。</p>

<p>C的单例类可以成为D的单例类的父类。</p>

<p>eval,</p>

<p>instance_eval, 把self改成调用的对象 a.instance_eval { p self }</p>

<p>class_eval(module_eval)，使得代码可以进入到类定义体中。和打开类最大的区别在于可以获得外围作用域。
<code>
var = 'initial'
c.class_eval do
  puts var
  def some_method
      puts var
  end</p>

<p>  #要想在实例方法中获得访问var的scope，可以使用define_method
  define_method("talk") {puts var}
end
</code></p>

<h3>Proc对象</h3>

<pre><code>pr = Proc.new { puts "inside a proc's block" }
pr.call #总是通过call来调用
</code></pre>

<p>Proc对象有闭包，会记录下它被定义时的变量，即携带它自己的上下文，而不管调用时的上下文。</p>

<p><code>
a = "aaaa"
pr = Proc.new {puts a}
pr.call => "aaa"
a = "bbb"
pr.call => "bbb"
</code></p>

<h1>总是会调用当时定义域中的引用</h1>

<p>proc对象可跟参数, Proc.new {　|x| p x }</p>

<h3>lambda</h3>

<p>lambda也是一个Proc对象，调用方法和lambda一样，定义方法是 l = lambda { puts &#8220;aaa&#8221;}，也是实现闭包的。同Proc.new的区别在于，lambda中的return仅仅从代码块中返回，而Proc.new中则是从调用者中返回，即调用者余下的代码不会被执行下去。</p>

<p>proc和lambda可以被当做代码块进行互相转换，虽然实际上ruby中并没有匿名代码块这个对象。
引用方法是加&amp;
grab_block λ {&#8230;}</p>

<h3>回调方法和钩子方法</h3>

<p>If this then that</p>

<ul>
<li><p>调用一个不存在的method
<code>
def method_missing(m, <em>args, &amp;block)
@recipes.send(m,</em>args,&amp;block)
end
</code>
这样一个类马上就能拥有@recipese所具备的方法。</p></li>
<li><p>一个模块被混含 Module#included</p></li>
</ul>


<p>最基本的用途是在include后给类或者模块增加类方法。原来叫做append_features
<code>
module M
  def self.included(c1)
    def c1.a_class_method
    end
  end</p>

<p>  def an_inst_method
  end
end</p>

<p>class C
  include M
end
</code></p>

<ul>
<li>一个类被继承 Class#inherited
<code>
module ActiveRecord
class Base
  @@subclasses = {}
  def self.inherited(child)
    @@subclasses[self] ||= []
    @@subclasses[self] &lt;&lt; child
    super
  end
end
end
</code></li>
</ul>


<h3>Module#const_missing</h3>

<p>覆盖和增加核心功能
alias :old_match :match，
可以自由的打开类并修改类</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/24/the-end-of-term2/">学期2结束</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-06-24T16:48:00+08:00" pubdate data-updated="true">Jun 24<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天结束了分布式系统的考试，第二学期在本周（第17周）实际已经结束了。
题目有点难，也谈不上做的好不好，毕竟最近一周事情比较多，自己的脚伤了后也耽误了复习。研究生考试的强度不大，过关应该还是可以的。要说一下的是那本教材，真是翻译的没法再差了。43个翻译者翻译出来的东西，这种质量的也不知道怎么就出版了，唉,绝对是悲剧。</p>

<p>今天终于借了ruby for rails，看了第一章，还是有收获的，打算进一步学习一下语言的特性。而且结合应用讲，可以比单纯的讲一个语言更接近现实，也就是提供怎么使用的方法。运用永远比知识更重要。书有点老了，原作是2006年出版，译本也是07年的作品了，时间检验过的东西还是比较可靠的。</p>

<p>个人从Rails中获得的东西良多，开拓了思路也眼界，也能站在一个更先进的位置看着各种技术的变迁与发展，这种感觉很棒。</p>

<p>今天还借了另外几本书，大癫狂、吴敬琏传、HTML5，希望可以接下来多看看吧。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/28/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/26/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2025/04/30/cong-bing-fa-dao-kotlinhe-mo-shi-de-xue-xi/">从并发到Kotlin和模式的学习</a>
      </li>
    
      <li class="post">
        <a href="/blog/2022/04/23/wfh-yi-ge-ban-yue/">WFH一个半月</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/12/30/2021-crvyang-che-cheng-ben-hui-zong/">2021 CRV养车成本汇总</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/10/26/the-kubernetes-book/">The Kubernetes Book</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/10/04/java-8-9-10-in-action/">Java 8 9 10 in action</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/技术'>技术 (96)</a></li><li><a href='/blog/categories/生活'>生活 (54)</a></li><li><a href='/blog/categories/车车'>车车 (40)</a></li><li><a href='/blog/categories/java'>Java (36)</a></li><li><a href='/blog/categories/读书笔记'>读书笔记 (26)</a></li><li><a href='/blog/categories/时评'>时评 (24)</a></li><li><a href='/blog/categories/神器'>神器 (23)</a></li><li><a href='/blog/categories/笔记'>笔记 (21)</a></li><li><a href='/blog/categories/ruby'>Ruby (18)</a></li><li><a href='/blog/categories/spring'>Spring (15)</a></li><li><a href='/blog/categories/项目管理'>项目管理 (14)</a></li><li><a href='/blog/categories/rails'>Rails (13)</a></li><li><a href='/blog/categories/linux'>Linux (12)</a></li><li><a href='/blog/categories/软考'>软考 (8)</a></li><li><a href='/blog/categories/云计算'>云计算 (6)</a></li><li><a href='/blog/categories/crv'>Crv (6)</a></li><li><a href='/blog/categories/nodejs'>Nodejs (6)</a></li><li><a href='/blog/categories/nosql数据库'>Nosql数据库 (5)</a></li><li><a href='/blog/categories/旅游'>旅游 (4)</a></li><li><a href='/blog/categories/管理'>管理 (4)</a></li><li><a href='/blog/categories/装机'>装机 (4)</a></li><li><a href='/blog/categories/heroku'>Heroku (4)</a></li><li><a href='/blog/categories/读书列表'>读书列表 (3)</a></li><li><a href='/blog/categories/git'>Git (3)</a></li><li><a href='/blog/categories/script'>Script (3)</a></li><li><a href='/blog/categories/mac'>Mac (2)</a></li><li><a href='/blog/categories/期刊'>期刊 (2)</a></li><li><a href='/blog/categories/外刊'>外刊 (2)</a></li><li><a href='/blog/categories/java'>Java (36)</a></li><li><a href='/blog/categories/键盘'>键盘 (1)</a></li><li><a href='/blog/categories/测试'>测试 (1)</a></li><li><a href='/blog/categories/安卓'>安卓 (1)</a></li><li><a href='/blog/categories/kotlin'>Kotlin (1)</a></li><li><a href='/blog/categories/区块链'>区块链 (1)</a></li><li><a href='/blog/categories/读书'>读书 (1)</a></li></ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2025 - Hegel 2011 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Web Statistics" href="http://getclicky.com/66623321"><img alt="Web Statistics" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
  <script src="//static.getclicky.com/js" type="text/javascript"></script>
  <script type="text/javascript">try{ clicky.init(66623321); }catch(e){}</script>
  <noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/66623321ns.gif" /></p></noscript>

</p>

</footer>
  







<script type="text/javascript">
    (function() {
        var twitterWidgets = document.createElement('script');
        twitterWidgets.type = 'text/javascript';
        twitterWidgets.async = true;
        twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
        document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
</script>




</body>
</html>
