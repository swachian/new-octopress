
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Hegel2011的博客</title>
  <meta name="author" content="Hegel 2011">

  
  <meta name="description" content="不少人应该对Oracle的报价是好奇的，研究了一番之后，发现Oracle的报价无论在商务上还是使用策略上都可以称之为出奇的成功. Oracle的数据库种类 Oracle的数据库讲穿了只有一套，但又分成ee、se等几个版本。而这些都可以提供免费试用。
通过免费可以培养用户群，降低工程师的雇佣成本。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://octopresszhangyu.herokuapp.com/blog/page/16/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Hegel2011的博客" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Hegel2011的博客</a></h1>
  
    <h2>读书 - 工作 - 生活 - 笔记</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:octopresszhangyu.herokuapp.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">关于自己</a></li>
  <li><a href="/blog/2015/02/20/to-read-list/">To-Read</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/28/the-price-of-oracle/">Oracle的价格</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-28T14:57:00+08:00" pubdate data-updated="true">Mar 28<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>不少人应该对Oracle的报价是好奇的，研究了一番之后，发现Oracle的报价无论在商务上还是使用策略上都可以称之为出奇的<strong>成功</strong>.</p>

<h3>Oracle的数据库种类</h3>

<p>Oracle的数据库讲穿了只有一套，但又分成ee、se等几个版本。而这些都可以提供免费试用。
通过免费可以培养用户群，降低工程师的雇佣成本。通过划分版本，又可以执行价格策略，抢占不同的市场。</p>

<h3>Oracle的单价种类</h3>

<p>Oracle的单价基本可以分为按User和按CPU卖。User的话是一个自然人或者设备。CPU就是按装机卖了。</p>

<p>下面是一些价格举例，单位都是美刀
按用户： {企业版： 950，se: 350, seo: 180}
按cpu: {企业版：47500， se：17500，seo：5800}</p>

<h3>Oracle的起步license概念</h3>

<p>显然，按user大部分情况下应该比较便宜。所以，邪恶的oracle又有了最小license数量的概念。比如，企业版最低的user数就是25，se则是5，以此来保证oracle的收入。</p>

<h3>折扣</h3>

<p>以上只是目录价，一般通过代理买，获得一半的折扣是没有多少问题的。如果是大客户的话，还可以更加优惠。</p>

<p>最后，说一下关于DataGuard的事情。有说是免费的，也有说是付费的。在10g的ee版本中，这个确实已经包含了。</p>

<blockquote><p>Data Guard supports both physical standby and logical standby sites. Oracle Corporation makes Data Guard available only as a bundled feature included within its &#8220;Enterprise Edition&#8221; of the Oracle RDBMS.</p></blockquote>

<p>所以，10g ee里面的ODG肯定是免费的，因为已经买过单了。</p>

<blockquote><p>The &#8220;Oracle Active Data Guard&#8221; option, an extra-cost facility,[4] extends Oracle Data Guard physical standby functionality in Oracle 11g configurations. It allows read-only access on the standby node at the same time as applying archived transactions from the primary node.[5]</p></blockquote>

<p>然后，在11g里面，又推出了Active Data Guard，二者在技术上有什么区别还没研究过，但在付费上这是一个可选包。目录价200/user.</p>

<p>参考资料：</p>

<ol>
<li><p><a href="http://www.oracle.com/us/corporate/pricing/technology-price-list-070617.pdf">oracle price list</a></p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Oracle_Data_Guard">oracle data guard wiki</a></p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/24/wei-shi-yao-rubybu-huo-reng-ran-zhi-de-xue/">为什么ruby不火仍然值得学</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-24T16:14:00+08:00" pubdate data-updated="true">Mar 24<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>从某些角度而言，这本不是问题，毕竟因为什么东西火就去学习什么东西的话，那么学与不学什么就无需再计较了。世上总有火的和流行的东西，仅就IT而言，Java火了很多年，这几年安卓 iOS的开发者的需求也很旺盛。如果想学火的东西，那么尽可以去学这些。一旦一样一个东西不怎么火，<strong>反而更可以看出大家为什么要学它。</strong></p>

<p>喜欢ruby可以有多个理由，特别是在rails引进门之后。在我看来，可以有以下几点。</p>

<h3>1. 简单</h3>

<p>换个术语可以叫做用户友好。ruby确实是简单的，相对于C、JavaScript而言。当然，ruby也可以用的很复杂，只是那通常是不需要进入的。</p>

<h3>2. 方便</h3>

<p>这是所有脚本语言的特长，写起来比较方便，不啰嗦。Java也很简单，但是太啰嗦，还需要编译等，所以我还是倾向于在辅助任务中使用ruby而非java。
方便的另一个同义词是表达力强。拥有的表达方式多，而且够简短，即信息量高。</p>

<h3>3.程序员（IT人员）的朋友</h3>

<p>和友好性不同，这是指真的可以用来作为日常工作的工具，用IT技术解决自己工作中的问题。而不仅仅是用IT技术解决客户等其他人的问题。</p>

<h3>4. Rails</h3>

<p>不可忽视，很多人是因为Rails才接触了ruby。至于为什么要学Rails，那可以单独再开一片文章了。大体上是因为Rails的先进和效率。但是，Rails
的引入<strong>大大提高了学习曲线</strong>。Ruby是简单的，不过加进Rails，那就复杂了。
不过如果想用Rails，想通过Rails学习东西，学习一些好的实践和想法，就必须去学习Ruby。</p>

<p>以上是我对ruby不够火的回答。希望学习火的东西人可以去学当前热门的那些东西。Java太平常的话，那就iOS开发、安卓开发，这些都是大面积缺人的。当然，我揣测提问者心里真实的想法是：
现在学ruby是希望今后有一天她能火，然后自己就可以抬高身价。而这东西既然始终不火，那似乎就没有投资学习的必要。</p>

<p>对于这种想法，自然是没有问题的。关键还是在于有没有其他的投资方向。如果有而且看准了，自然可以去新的方向。我们不是Mats也不是DHH，即使是学ruby的人离开也不会有很大的损失，何况本来就持观望态度的人呢？</p>

<p>如果是想靠web技术发财，那么最重要的还是棒个好的创业伙伴，技术此时是次要的，业务和产品才是关键。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/16/sass-and-compass/">Sass and Compass</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-16T21:29:00+08:00" pubdate data-updated="true">Mar 16<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Sass 和　Compass闻名已久，也接触过一些，不过始终没有仔细学过。这次因为要做移动互联页面的东西，又开始接触这部分内容。
看了下《Pragmatic Guide to Sass》, 理清了一下脉络。
顺便提一句，这本书是在kindle上看的，出版社和作者提供了epub的版本。  这可以算是第一本在kindle上看完的计算机技术类书籍。虽然效果还可以，
但是看了下原书的pdf版本，发现其版本也深受“小书”，小版面，的影响。这可能是未来计算机书籍的一个趋势吧。不过kindle还是最适合纯文字，
用来阅读计算机技术书籍的体验还是很一般。</p>

<p>Sass是最基础的，类似coffeeScript对Css的改写，当然引入的内容要多的多。毕竟js本身也是一种语言，但css很难算的上是一门编程语言。
Sass有自己的运行命令，由ruby实现，可以把scss文件编译成css文件，也能convert回去。</p>

<p>Compass则是sass的库和扩展，在sass的基础上提供了更丰富的样式、函数和变量以及模式。其本身也有了一套命令，也更适合于建项目。Sass如果是java，
那么compass就是J2EE+Eclipse。</p>

<p>如果不想安装那么多东西，那么可以直接使用scout这个GUI工具，工具本身集成了sass和compass的能力，只是又提供了图形化的集成界面。该界面可能是基于
Adobe的桌面技术编写的。如果要推荐美工使用sass，那么可以从scout入手。</p>

<p>compass是很神奇的，而它的spriting堪称神奇中的神奇。</p>

<p>但我发觉设计也是有天赋和术业专攻的。我们的美工完全不用这些东西，也很快就能搞出一个各种android上面看过去还不错的版本，我用这些东西去写出来的还是感觉很累。但至少比没有要好多了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/08/notes-of-matz-on-ruby-2-dot-0-at-herokus-waza/">Notes of Matz on Ruby 2.0 at Herokus Waza</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-08T11:15:00+08:00" pubdate data-updated="true">Mar 8<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://speakerdeck.com/yukihiro_matz/ruby-2-dot-0-en">Mats Ruby 2.0</a>
的笔记。</p>

<p>首先讲了Ruby的历史</p>

<ul>
<li>Dec 1995 0.95</li>
<li>Dec 1996 1.0</li>
<li>Aug 1997 1.1</li>
<li>Dec 1998 1.2</li>
<li>Aug 1999 1.4</li>
<li>Sep 2000 1.6</li>
</ul>


<p>以上是节假日驱动开发，后来改成了周年纪念开发，呵呵。</p>

<p>voccation-driven development<br/>
Anniversary-driven development</p>

<ul>
<li>Aug 2003 1.8</li>
<li>Dec 2007 1.9.0</li>
<li>Aug 2010 1.9.2</li>
<li>Oct 2011 1.9.3</li>
<li>Feb 2013 2.0.0</li>
</ul>


<p>2.0版最早是在Ruby Conf 2001提出，包括</p>

<ul>
<li>new GC</li>
<li>native Thread with GIL</li>
<li>有些特性后来放弃了</li>
</ul>


<p>2.0的发布带来了：</p>

<ul>
<li>New Hash literals</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  {foo: 1, bar: 2} =&gt; {:foo=&gt;1, :bar=&gt;2}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>keyword arguments</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  def log(msg, level: "ERROR", time: Time.now)
</span><span class='line'>    puts "..."
</span><span class='line'>  end
</span><span class='line'>  
</span><span class='line'>  # existing hash passing
</span><span class='line'>  log("Hello!", **hash)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Module#prepend, alias method chain, from CommonLisp</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#prepend put them before to wrap methods
</span><span class='line'>class Foo
</span><span class='line'>  def foo; p :foo; end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>module Prepend
</span><span class='line'>  def foo
</span><span class='line'>    p :before
</span><span class='line'>    super
</span><span class='line'>    p :after
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>class Foo
</span><span class='line'>  prepend Prepend # just as include Prepend
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>Foo.new.foo
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>refine，to constrain open class, scoped monkey patching</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module R
</span><span class='line'>  refine String do
</span><span class='line'>    def foo
</span><span class='line'>      puts "aaa"
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>"".foo # =&gt; error!
</span><span class='line'>
</span><span class='line'>using R
</span><span class='line'>"".foo</span></code></pre></td></tr></table></div></figure>


<p>Java 和 Smalltalk有classbox的概念，也与此类似</p>

<ul>
<li>Enumerable#lazy， 受函数式编程影响</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(1..Float::INFINITY).lazy.map {|i|
</span><span class='line'>  i.to_s
</span><span class='line'>}.select {|s|
</span><span class='line'>  /3/ === s
</span><span class='line'>}.first(500000)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Symbol array literals</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>%i(foo bar baz) =&gt; [:foo, :bar, :baz]</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>to_h, to_hash</p></li>
<li><p>UTF-8 by default</p></li>
<li><p>Performance Faster:</p>

<ul>
<li>VM(YARV)</li>
<li>GC</li>
<li>require</li>
</ul>
</li>
</ul>


<p>Ruby 2.1 maybe 25.12.2013</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/04/deploy-a-rails-4-app-to-heroku/">Deploy a Rails 4 App to Heroku</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-04T20:03:00+08:00" pubdate data-updated="true">Mar 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>近期从<code>rvm</code>切换到了<code>rbenv</code>, ruby也全面升级到了2.0.0版本， Rails也装了4.0.0.beta，似乎一切欣欣向荣的样子。<br/>
为了方便测试获取一些设备的浏览器信息，写了一个自动获取并分析<code>User-Agent</code>的应用，并确定发布到heroku上。
在发布的过程中，发现还是有一些陷阱，也差不多被折腾了一个来小时,所以决定记录一下。</p>

<h3>0 事先准备</h3>

<p>虽然我用Heroku的时间可以追溯到很久以前，从 scanty 到 octopress，但到这次才发现其实之前我没在heroku上部署过Rails应用。
但这也意味着，第一我很早以前就有了Heroku的帐号，第二我的机器上的ssh-key同heroku都是打通的，第三已经安装了heroku这个gem。</p>

<h3>1 创建应用</h3>

<p>首先执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>heroku apps:create user-agent-show2
</span></code></pre></td></tr></table></div></figure>


<p>这样会在heroku处创建一个stack，目前版本是<code>cedar</code>. 同时，在.git/config里面会增加一个heroku分支</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[remote "heroku"]
</span><span class='line'>        url = git@heroku.com:user-agent-show.git
</span><span class='line'>        fetch = +refs/heads/*:refs/remotes/heroku/*</span></code></pre></td></tr></table></div></figure>


<h3>2 Git push</h3>

<p>随后就可以执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git push heroku</span></code></pre></td></tr></table></div></figure>


<p>部署应用了。
但这里就会碰到陷阱。首先，Heroku是支持pg的应用，所以需要在Gemfile里增加<code>gem 'pg'</code>，同时也要确保这个gem在本机有依赖的Native包。对于ubuntu，
基本需要安装<code>apt-get install libpq-dev</code> 这个包，不过这个包很小，只有900多KB。</p>

<p>其次，对于assets，可以选择预先执行<code>rake assets:precompile</code>，也可也让heroku在部署时执行。但默认情况下生成的js和css文件是访问不到的。
因为rails 4默认生成environments/production.rb中是这样配置的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>config.serve_static_assets = false</span></code></pre></td></tr></table></div></figure>


<p>这个会导致thin或者unicorn不负责对静态文件的处理。如果是基于Nginx或者Apache之类的部署，这点毫无问题，因为代理在收到请求后就处理掉了，但
对于heroku，则在起初时是必须由thin负责这部分内容的，因此需要把上面的配置改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>config.serve_static_assets = true</span></code></pre></td></tr></table></div></figure>


<p>这样才能保证静态文件被正常访问。</p>

<h3>3 数据库更新</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>heroku run rake db:migrate</span></code></pre></td></tr></table></div></figure>


<p>push成功后，就可以执行迁移了。也能执行<code>heroku run bash</code> 等命令去查看云服务器的实际运行情况。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/26/change-to-ruby-2-dot-0-0/">Change to Ruby 2 Dot 0 0</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-26T00:00:00+08:00" pubdate data-updated="true">Feb 26<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>layout: post
title: &#8220;Change to Ruby 2.0.0&#8221;
date: 2013-02-26 11:30
comments: true
categories:
- ruby
- heroku</p>

<hr />

<p>借着Ruby 2.0.0发布的东风，又加之Rails 也发布了4.0.beta来给献礼，营造了RR24，我也把octopress升级到了ruby 2.0.0.</p>

<p>步骤如下：</p>

<ol>
<li>在Gemfile中加入 <code>ruby "2.0.0"</code></li>
<li>更新Gemfile中其他的一些gem，把octopress最新版的内容加进来即可，否则可能还是不能和2.0兼容的</li>
<li><code>bundle intall</code>, <code>bundle install --binstubs</code></li>
<li><code>git commit -a</code></li>
<li><code>git push heroku</code></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Counting objects: 119, done.
</span><span class='line'>Compressing objects: 100% (59/59), done.
</span><span class='line'>Writing objects: 100% (60/60), 5.46 KiB, done.
</span><span class='line'>Total 60 (delta 32), reused 0 (delta 0)
</span><span class='line'>-----&gt; Deleting 5 files matching .slugignore patterns.
</span><span class='line'>-----&gt; Ruby/Rack app detected
</span><span class='line'>-----&gt; Using Ruby version: ruby-2.0.0
</span><span class='line'>-----&gt; Installing dependencies using Bundler version 1.3.0.pre.5
</span><span class='line'>       Ruby version change detected. Clearing bundler cache.
</span><span class='line'>       Old: ruby 1.9.2p290 (2011-07-09 revision 32553) [x86_64-linux]
</span><span class='line'>       New: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-linux]
</span><span class='line'>       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
</span><span class='line'>       Fetching gem metadata from http://ruby.taobao.org/.
</span><span class='line'>       Fetching full source index from http://ruby.taobao.org/
</span><span class='line'>       Installing daemons (1.1.8)
</span><span class='line'>       Installing eventmachine (0.12.10)
</span><span class='line'>       Installing rack (1.4.1)
</span><span class='line'>       Installing rack-protection (1.3.2)
</span><span class='line'>       Installing tilt (1.3.3)
</span><span class='line'>       Installing sinatra (1.3.5)
</span><span class='line'>       Installing thin (1.4.1)
</span><span class='line'>       Using bundler (1.3.0.pre.5)
</span><span class='line'>       Your bundle is complete! It was installed into ./vendor/bundle
</span><span class='line'>       Cleaning up the bundler cache.
</span><span class='line'>-----&gt; Discovering process types
</span><span class='line'>       Procfile declares types     -&gt; (none)
</span><span class='line'>       Default types for Ruby/Rack -&gt; console, rake, web
</span><span class='line'>
</span><span class='line'>-----&gt; Compiled slug size: 30.5MB
</span><span class='line'>-----&gt; Launching... done, v48</span></code></pre></td></tr></table></div></figure>


<p>但我不太理解slug size为啥变大了。</p>

<p>而且和thin里面的eventmachine配合似乎有问题，可能是版本太老，也可能是别的什么，
于是改用了unicorn，又折腾了Procfile</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>web: bundle exec unicorn -p $PORT</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Total 3 (delta 1), reused 0 (delta 0)
</span><span class='line'>-----&gt; Deleting 5 files matching .slugignore patterns.
</span><span class='line'>-----&gt; Ruby/Rack app detected
</span><span class='line'>-----&gt; Using Ruby version: ruby-2.0.0
</span><span class='line'>-----&gt; Installing dependencies using Bundler version 1.3.0.pre.5
</span><span class='line'>       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
</span><span class='line'>       Using kgio (2.8.0)
</span><span class='line'>       Using rack (1.4.5)
</span><span class='line'>       Using rack-protection (1.3.2)
</span><span class='line'>       Using raindrops (0.10.0)
</span><span class='line'>       Using tilt (1.3.3)
</span><span class='line'>       Using sinatra (1.3.5)
</span><span class='line'>       Using unicorn (4.6.2)
</span><span class='line'>       Using bundler (1.3.0.pre.5)
</span><span class='line'>       Your bundle is complete! It was installed into ./vendor/bundle
</span><span class='line'>       Cleaning up the bundler cache.
</span><span class='line'>       Would have removed thin (1.4.1)
</span><span class='line'>       Would have removed daemons (1.1.9)
</span><span class='line'>       Would have removed daemons (1.1.8)
</span><span class='line'>       Would have removed thin (1.5.0)
</span><span class='line'>       Would have removed rack (1.4.1)
</span><span class='line'>       Would have removed eventmachine (1.0.0)
</span><span class='line'>       Would have removed eventmachine (0.12.10)
</span><span class='line'>-----&gt; Discovering process types
</span><span class='line'>       Procfile declares types     -&gt; web
</span><span class='line'>       Default types for Ruby/Rack -&gt; console, rake
</span><span class='line'>
</span><span class='line'>-----&gt; Compiled slug size: 35.9MB
</span><span class='line'>-----&gt; Launching... done, v53</span></code></pre></td></tr></table></div></figure>


<p>最后重新弄了一下，发现还是很大。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Writing objects: 100% (3/3), 281 bytes, done.
</span><span class='line'>Total 3 (delta 2), reused 0 (delta 0)
</span><span class='line'>-----&gt; Deleting 5 files matching .slugignore patterns.
</span><span class='line'>-----&gt; Ruby/Rack app detected
</span><span class='line'>-----&gt; Using Ruby version: ruby-2.0.0
</span><span class='line'>-----&gt; Installing dependencies using Bundler version 1.3.0.pre.5
</span><span class='line'>       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
</span><span class='line'>       Using kgio (2.8.0)
</span><span class='line'>       Using rack (1.4.5)
</span><span class='line'>       Using rack-protection (1.3.2)
</span><span class='line'>       Using raindrops (0.10.0)
</span><span class='line'>       Using tilt (1.3.3)
</span><span class='line'>       Using sinatra (1.3.5)
</span><span class='line'>       Using unicorn (4.6.2)
</span><span class='line'>       Using bundler (1.3.0.pre.5)
</span><span class='line'>       Your bundle is complete! It was installed into ./vendor/bundle
</span><span class='line'>       Cleaning up the bundler cache.
</span><span class='line'>-----&gt; Discovering process types
</span><span class='line'>       Procfile declares types     -&gt; web
</span><span class='line'>       Default types for Ruby/Rack -&gt; console, rake
</span><span class='line'>
</span><span class='line'>-----&gt; Compiled slug size: 27.3MB
</span><span class='line'>-----&gt; Launching... done, v5
</span><span class='line'>       http://octopresszhangyu.herokuapp.com deployed to Heroku</span></code></pre></td></tr></table></div></figure>


<p>感觉adam不再怎么发文之后，Heroku有点日趋堕落的趋势。另外，在Procfile里面运用unicorn绝对是个好主义。其效果类似一个dyno(ubuntu)上跑了几个unicorn的进程，
明显处理能力会强于只有一个实例的thin。以上灵感来自<a href="http://blog.codeship.io/2012/05/06/Unicorn-on-Heroku.html">unicorn的部署高人</a>。</p>

<p>今日装某个系统，发现有掉到了libyaml这个沟里。试了几次，最后发现是 <code>LD_LIBRARY_PATH=</code>的缘故。
编译好libyaml，在加入到上面这个环境变量中，ruby才能读的出来。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/19/about-awk/">About AWK</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-19T14:52:00+08:00" pubdate data-updated="true">Feb 19<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>受 <a href="http://coolshell.cn/articles/9070.html">AWK简明教程</a> 的影响，学习了一下仰慕已久却始终不得要领的AWK，
甚至还下载了著名的科尔尼汉写的《The AWK programming Language》并看完了第一章和后面的一些内容。</p>

<p>学习之后，发现这个东西其实还是很简洁的，同bash的配合确实很好，在某些应用场合下，处理文本、截取文本、调整文本，的确是利器。
但是，也必须注意到，这个东西确实已经是上古一代的东西了。不是说上古的东西就一定使用价值降低，不过AWK的作用和处理范围
已经大大地被Python和Ruby侵占。在Unix/C之下，他是足够简便的，对bash是很好的补充。如今已经是Ruby Python这些
script流行的年代，而这些脚本语言可以很大程度上替代AWK。AWK保留的优势仅仅是最简单的场合下，比如<code>{print $1}</code>之类时
显得足够简洁的优势。稍微复杂一些，如循环、分支判断一多，就显得不如Ruby Python了。</p>

<p>所以，看AWK的第一章以及简明教程就足够了。因为基本上也只要用到这些最简单的应用，写出优雅的bash命令。是用来写程序<strong>命令</strong>而不是程序<strong>文件</strong>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/09/journal-of-computer-application/">期刊读后感</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-09T16:45:00+08:00" pubdate data-updated="true">Feb 9<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>读了去年年底订阅的《计算机应用》，发现还是有一些文章是值得一读的。
订阅这个杂志是因为觉得发文速度还算快，期刊和文章的档次也还不错。看了2013年第2期，里面还是有六七篇很有收获的文章的。
必须承认的是，期刊文章的质量普遍比网上的资料要高。</p>

<p>按钱学森的理论，做研究的一大秘诀是阅读文献，因为大部分问题肯定都有人面对过，从中获取启发再进行突破才能取得更好的效果。
这个理论对计算机也是适用的，实际上信息技术里面阅读文献的效果要超过其他工程专业。毕竟信息行业里思路和实现之间的差距
比其他的要短的多。</p>

<p>虽然已经是互联网时代，但要探索自己未知的还是离不开杂志的。首先搜索的素材的一大来源就是期刊，搜索本身并不制造内容，内容的一大制造者
就是期刊。尽管现在网上的博客、科技文章等素材已经很广阔，但其质量普遍还是不如期刊的。原因在于发表期刊真的是挺难的，你给拿出自己的
拿手好戏才行，没有的点真东西期刊的编辑是不会买账的。质量普遍较高是期刊的第二大优势，毕竟既要自己花钱又有审稿者和编辑把关，质量高于
网上的其他资料是很正常的。最重要的，只有期刊才能让你可能接触自己不熟悉的东西。搜索是目的性很明显的阅读方式。但当你没有明确的方向时
搜索是帮不上忙的。而高质量的期刊可以弥补搜索的这个弱点。虽然你要忍受一堆可能没有用或者自己读不进去的内容，但总的来说，产出投入比
还是很大的，还是很值得这么做的。我阅读了一期，就有了以下几点收获：</p>

<ol>
<li>对基站提供的定位信息的应用有了新的认识。原来还可以用来跟踪用户的行动路径，为换乘乃至规划和其他促销活动提供依据。</li>
<li>均衡服务可以使用HiCuts算法，其实就是一种决策树，在分类时可以使用，丰富自己的分类依据，以前主要也就是有个hash的概念。</li>
<li>小波算法其实和取log差不多，最大的意义在于提高监测值可感知效果。</li>
<li>聚类后对数据特征值的取顶叫做概化，可以是平均值，也可以是区间。</li>
<li>网页防篡改分远程和本地两种，远程的把内容按动态和静态区分应该也算一个思路。话说我的第一个防篡改方案也是看期刊获得灵感。</li>
<li>排班优化原来也是人工智能的一部分。</li>
<li>网管软件的组件可以按主站、代理、代理数据信息、网管协议4个组件来进行组织，对写此类文章有了更好的心得，毕竟描述一个系统要写成期刊是很难的。</li>
</ol>


<p>短短时间，收获已经很多。</p>

<p>不过期刊也有不足之处。最大的问题可能在于计算机期刊的文章刊出时间都太长了。投稿半年内能读到的已经是凤毛麟角，一年以上是常态，
最nb的期刊基本要3年。套用一句俗话，这好像是和一个25岁的2个孩子的妈谈恋爱，不新鲜的东西往往有时候就没使用价值了。从这点上来讲，计算机应用和
计算机系统应用都做的很不错。</p>

<p>还有一点，就是计算机应用里面也包含了大量计算机科学的内容。因为科学两个字，搞得天下计算机从业者往往都喜欢套数学，这个也是阻碍业界接受期刊的一大障碍吧。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/05/patch-and-diff/">Patch and Diff</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-05T10:52:00+08:00" pubdate data-updated="true">Feb 5<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>patch和diff确实是个神奇的东西，用来对现有版本的升级是最好不过了。
好处在于一来不用停业务，二来可以明确到底改了多少东西。</p>

<h3>diff</h3>

<p>首先来说说diff，毕竟patch是从此处产生。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>diff -ruNa src dest  &gt; a.patch
</span><span class='line'>
</span><span class='line'>-r 针对整个目录  
</span><span class='line'>-u 以合并的方式来显示文件内容的不同
</span><span class='line'>-N 新文件做空白文件
</span><span class='line'>-a 包含二进制内容，如jar包，class等</span></code></pre></td></tr></table></div></figure>


<p>据说这个东西是perl的发明者创建的工具，主要用于比较源码，通常不带<code>-a</code>。</p>

<h3>patch</h3>

<p>patch就比较强大了。如果是更改一个目录下面，最常见的做法是进入该目录，然后执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>patch -p1 &lt; ../a.patch </span></code></pre></td></tr></table></div></figure>


<p>随后，两个目录就会变得一模一样了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/03/should-we-try-to-pursue-a-master-degree/">Should We Try to Pursue a Master Degree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-03T15:23:00+08:00" pubdate data-updated="true">Feb 3<span>rd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当我还在高中时，是否需要读一个硕士学位根本不是一个问题。因为我当时很明确地不想。以当时的认知水平，如果进一个名牌大学的热门专业，基本可以解决
毕业后的生计问题。彼时的大学生也根本不怎么考虑找工作或者市场需求的事情。因为总人数也就是如今本科生的七分之一，比如今的研究生总数也多不出多少。
在这样的轻压下，就业不愁，很多人也是没有攻读硕士文凭的想法的。</p>

<p>但是，在我读本科至毕业期间，又是研究生和本科生的待遇差别最大的那几年。那应该是考研竞争最激烈的几年，于是动过考研的念头。然而，在我了解了实验室师兄们的研究生生活后，
我又打消了考研的念头。为什么？</p>

<p>第一，是给导师打工的感觉并不好。被压榨的比较厉害。这一点和现在是有区别的，现在因为研究生大量扩招，很多老师其实也不需要那么多学生干活，或者说
人多了每个人能做的事情和出的力气只能降低。而在那时候，一个研究生的工作压力还是很大的。而同样的压力下，自然是公司给的钱更多。出于经济的考虑，自然
应当选择工作。第二，在专业能力方面，如果是无所事事只是读书，那么进步很慢，个人也只会感觉到自己啥都不会。虽然就业时一般把自己卖的还不错，但自己
的本事自己最清楚。当然，公司老板不是傻瓜，卖的好也有卖的好的道理。如果是干老板的打工的活，那和自己直接去公司中接触现实项目没区别。研究生所带来的
起点高，是以损失两三年时间等换来的。之所以自己感觉研究生的待遇比本科生好许多，一大因素是当时没把年纪和时间的因素权衡好。总之，读研在此时显得
意义不大。</p>

<p>但是，在内心深处，自己又是想拥有研究生的文凭的。毕竟对一个书呆子而言，有没有这样一个东西绝非毫无意义的事情。如前所说，大学几年读完，意志品质
增强，但个人并没有什么创造财富的技能。虽然行情不错，自己知道自己实际上并没有为公司、为社会创造财富的能力，做不出什么社会上需要的东西。中国的
知识分子往往不在意现实世界的问题，更多的是关心自己这个圈子和世界里的问题，自己在这个相对封闭的环境中所取得的成绩和title等。</p>

<p>而到如今，择业的机会也更多了，光凭一个研究生文凭能不能找到好的工作也变得两说。当然，优秀学校的研究生还是很热门的，毕竟这部分资源是难得的。这
也是过去的名牌大学本科生即使啥都不会，但还是很有行情的根本原因&#8212;&#8211;优秀的智力资源当然哪里都是需要的，世界上总有现实的问题需要聪明人才能解决。而
一个好大学的研究生往往还是具备这种能力，毕竟国家替公司先选择过一回了。</p>

<p>所以，读了研究生的同学，其竞争力和未来所能取得的成绩和生活水平应该还是会高于本科生的平均水平。尤其对于想进入体制内的企业的年轻人而言。可能对于
互联网小型公司有没有硕士文凭真的不重要，对体制内的单位，包括银行、石油、电力等，从事这些单位的IT工作，攻读出来的研究生学位还是很有用的。
这些单位的待遇也不错，我国又是公有经济为主的国度，去这些巨头研究生的文凭将很有用处。比如本系的研究生1/4左右会去银行，但本系的本科生去银行的比例
要低得多了，银行又是目前的优势行业，如果定位自己想去做金融业的IT，那么研究生文凭会派上很大的用场。<br/>
即使有些人对体制内的企业不感兴趣，那么只要你是去大公司，是去巨头，那么研究生文凭都将是有用处的。哪怕是淘宝、腾讯和百度，研究生的机会和起点都
仍然比本科生好许多。当然，需要你有一个不错的学校，好学校的招牌也很重要。</p>

<p>前面已经说了，如今的时代也是机会多多的时代。很多需要处理实际问题的地方，对学历确实是无所谓的，如果你有特殊技能或者能力真的特别强。这部分能力当然也不是学校能教会的，
这些能力来自自己的业余项目以及自己的实践。如果有如此能力，又想赚到大钱的话，完全可以本科毕业就找一个认得准的公司开干。如何认准呢？这个就看你积累的
能力了。如果你也认不准，那么就只能碰运气了。抱定这个想法的话，也是可以过得不错的。现实中已经有大量的IT技术小杰是其他专业转过来的，他们的背景和
资质不少也没有特殊之处，但也可以取得很不错的成绩。这就是现实给他们的机会造就了他们。</p>

<p>而对于又想和体制打交道，又想不给导师打很多工就拿到硕士文凭的，那么还是学我吧。</p>

<p>总之，如今的社会还是一个相对开明的，机会也不是没有，除了住房，大部分需求都还能够通过自己的努力获得。没有硕士文凭也可以做出正经事情。虽然硕士文凭
是有用的，但干活和工作也是很正经的事情，而且是来自现实世界的正经事情。硕士文凭在去体制内和大公司的时候特别有用，而且越大就越有用。如果想去大公司
那么可以读的还是去读一个吧。如果想靠自己闯的，那么建议大二大三稍稍有空闲时间即可实际接触现实世界的项目和技术。真的做到的话，竞争力会强于大部分
研究生，当然，现实是大部分本科生是做不到的，所以他们大部分也比不上硕士研究生。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/17/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/15/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2020/04/13/ru-shou-ben-jing-zhuang-shu/">入手本精装书</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/12/29/yu-jun-de-chan-pin-jing-li-fang-fa-lun/">俞军的产品经理方法论</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/12/29/crv-2019/">2019 CRV养车成本汇总</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/12/01/manage-it/">Manage It</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/11/05/feng-huang-xiang-mu-du-hou-ji/">凤凰项目读后记</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/技术'>技术 (85)</a></li><li><a href='/blog/categories/生活'>生活 (51)</a></li><li><a href='/blog/categories/车车'>车车 (37)</a></li><li><a href='/blog/categories/java'>Java (30)</a></li><li><a href='/blog/categories/读书笔记'>读书笔记 (25)</a></li><li><a href='/blog/categories/神器'>神器 (23)</a></li><li><a href='/blog/categories/时评'>时评 (23)</a></li><li><a href='/blog/categories/笔记'>笔记 (21)</a></li><li><a href='/blog/categories/ruby'>Ruby (18)</a></li><li><a href='/blog/categories/spring'>Spring (15)</a></li><li><a href='/blog/categories/项目管理'>项目管理 (14)</a></li><li><a href='/blog/categories/rails'>Rails (13)</a></li><li><a href='/blog/categories/linux'>Linux (11)</a></li><li><a href='/blog/categories/软考'>软考 (8)</a></li><li><a href='/blog/categories/crv'>Crv (6)</a></li><li><a href='/blog/categories/nodejs'>Nodejs (6)</a></li><li><a href='/blog/categories/云计算'>云计算 (6)</a></li><li><a href='/blog/categories/nosql数据库'>Nosql数据库 (5)</a></li><li><a href='/blog/categories/管理'>管理 (4)</a></li><li><a href='/blog/categories/heroku'>Heroku (4)</a></li><li><a href='/blog/categories/旅游'>旅游 (4)</a></li><li><a href='/blog/categories/装机'>装机 (3)</a></li><li><a href='/blog/categories/script'>Script (3)</a></li><li><a href='/blog/categories/读书列表'>读书列表 (3)</a></li><li><a href='/blog/categories/git'>Git (2)</a></li><li><a href='/blog/categories/mac'>Mac (2)</a></li><li><a href='/blog/categories/期刊'>期刊 (2)</a></li><li><a href='/blog/categories/外刊'>外刊 (2)</a></li><li><a href='/blog/categories/测试'>测试 (1)</a></li><li><a href='/blog/categories/安卓'>安卓 (1)</a></li><li><a href='/blog/categories/区块链'>区块链 (1)</a></li><li><a href='/blog/categories/键盘'>键盘 (1)</a></li></ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2020 - Hegel 2011 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Web Statistics" href="http://getclicky.com/66623321"><img alt="Web Statistics" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
  <script src="//static.getclicky.com/js" type="text/javascript"></script>
  <script type="text/javascript">try{ clicky.init(66623321); }catch(e){}</script>
  <noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/66623321ns.gif" /></p></noscript>

</p>

</footer>
  







<script type="text/javascript">
    (function() {
        var twitterWidgets = document.createElement('script');
        twitterWidgets.type = 'text/javascript';
        twitterWidgets.async = true;
        twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
        document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
</script>




</body>
</html>
