
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Hegel2011的博客</title>
  <meta name="author" content="Hegel 2011">

  
  <meta name="description" content="在深入学习JVM并发艺术的过程中，了解到Kotlin的协程拥有比JAVA 21的协程更加的性能，从而对了解Kotlin实际情况产生了兴趣。同时，又找到了一本基于Kotlin的，讲解Gof模式实践和并发模式实践的书籍，于是跟着整本书，把Kotlin也学习了一遍。本文会就Kotlin的特点， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://octopresszhangyu.herokuapp.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Hegel2011的博客" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Hegel2011的博客</a></h1>
  
    <h2>读书 - 工作 - 生活 - 笔记</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:octopresszhangyu.herokuapp.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">关于自己</a></li>
  <li><a href="/blog/2015/02/20/to-read-list/">To-Read</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2025/04/30/cong-bing-fa-dao-kotlinhe-mo-shi-de-xue-xi/">从并发到Kotlin和模式的学习</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2025-04-30T23:42:00+08:00" pubdate data-updated="true">Apr 30<span>th</span>, 2025</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在深入学习JVM并发艺术的过程中，了解到Kotlin的协程拥有比JAVA 21的协程更加的性能，从而对了解Kotlin实际情况产生了兴趣。同时，又找到了一本基于Kotlin的，讲解Gof模式实践和并发模式实践的书籍，于是跟着整本书，把Kotlin也学习了一遍。本文会就Kotlin的特点，相对于Java本身的优势和劣势做一些评价，也会对Kotlin高度配套的Arrow、Ktor、Vert.x写一些体会，同时，因为Kotlin明显受到了Scala的启发，所以也会谈一点关于scala的内容。</p>

<p>前4章讲了Kotlin的基础以及Gof的3类合计23个经典设计模式。Kotlin的语言风格和Java以及JS类似，实质上更像JS，因为她把函数作为一等公民，但很多语法又更像Java。</p>

<p>回忆要点：</p>

<h3>语法巡礼</h3>

<ul>
<li>打印语句是什么</li>
<li>简化的main方法</li>
<li>简化的分号semicolons</li>
<li>val var的类型声明以及类型推断</li>
<li>==和===的比较</li>
<li><p>Null safety</p></li>
<li><p>Lists, Sets, Maps的构造方式类似java，但有更明确的Mutable标识</p></li>
<li>数组，从list到数组以及arrayOf</li>
<li>if 和when控制语句</li>
<li>String里变量的解析 ${}</li>
<li><p>loop的写法</p></li>
<li><p>class和继承，用<code>:</code> 来表明继承</p></li>
<li>Properties及其method</li>
<li>必要时可给Property定制set get</li>
<li>interface和override</li>
<li>abstract class</li>
<li>只有open的class可以被继承，但通过编译糖实现了直接给现有类open一个method(Extension functions)</li>
<li>Data 类，也就是value object</li>
</ul>


<h3>创建有关的模式</h3>

<ul>
<li>单例 object关键字</li>
<li>Factory Method 是要抽象出被建对象的公共Interface</li>
<li>Abstract Factory 可以理解成是Factory Method的集成</li>
<li>Builder 目前很常用的方法，Kotlin里面增加了通过apply实现的Fluent setters，Default arguments等</li>
<li>Prototype Kt里面这就是一个copy</li>
</ul>


<h3>结构有关的模式</h3>

<ul>
<li>Bridge 引入中间对象类实现行为的委托，让原对象行为的变化通过变换bridge的对象来实现</li>
<li>Proxy 和Decorator一样，都包含一个传入的组合对象，只是更多的是做访问控制等工作，并且很可能执行路径和传入的参数很不一样</li>
<li>Decorator  <code>by repository</code>的意思是继承这个接口的时候使用输入的参数的实现类</li>
<li>Composite 把可能单个或者多个的同类参数组织起来，核心结构是包含一个集合，<code>varargs</code>关键字可以把输入的多个参数作为数组</li>
<li>Facade 把复杂的操作封装起来，这里举的例子有点像后面的中间人</li>
<li>Adapter asStream，asArray都是一种adapter的现实应用</li>
<li>Flayweight 通过缓存+单例实现内存使用减小</li>
</ul>


<h3>行为相关的模式</h3>

<p>责命解迭中记观，策状模访</p>

<p>Java的惯例是都是对象，所以所有的行为模式和结构模式都长的差不多。但是，对应Function优先的语言而言，Function不像对象那样是有状态的，所以可以实现纯策略模式。</p>

<ul>
<li>Chain of Responsibility 常见的filter其实就是一种责任链模式，通过提取一个公共的handler(比如request in response 出)函数为入参，就可以把这串方法串行调用起来</li>
<li>Command 把要执行的东西压入一个数组，然后提取出来分别执行，其实事件模型有点类似command，但command甚至可以执行回滚</li>
<li>Interpreter 解析复杂的文本为对象</li>
<li>Iterator  支持迭代模式的对象，就拥有了很多种和迭代器相关的能力，从遍历到map，reduce</li>
<li>Mediator 按他的说法，controller在MVC里就是一个中间人</li>
<li>Memento  顺便记录点东西</li>
<li>Observer launch等的核心模式</li>
<li>Strategy 这个其实是被使用的最多的一种模式，动态更换行为</li>
<li>State 通过状态不同来更新成员的状态对象，从而有不同的策略</li>
<li>Template Method 直接传入定制化的method，从而利用整个模板走完流程</li>
<li>Visitor 这个模式的核心其实是把不同元素的处理情况放到一个类中，用when或者switch进行集中处理，而这个类就叫visitor。她可以处理集合，处理集合时意味着丢给集合的accept后续处理，如遇到叶子结点，则直接对元素进行访问后获取自己需要的东西。</li>
</ul>


<p>随后本书进入了第二部分，关注于有反应(Reactive)和并发的Pattern。主要就是涉及FP（函数式编程）的模式，以及协程(Coroutines)、Channel、Flow等用于并发的组件。后者更像是基础框架对编程的影响，也由基础组件决定了程序编写的基本套路，即模式。<br/>
以协程为例，Java是17以后才引入的概念，之前只有线程。而Kotlin因为要为安卓服务，所以很早</p>

<h3>FP</h3>

<p>多核的兴起以及FP在意图性编程方面的优势，让FP翻红起来。</p>

<ul>
<li>function的几种写法，从最严格的到最简化的</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun generateMultiply1(): (Int, Int) -&gt; Int {
</span><span class='line'>    return fun(x: Int, y: Int): Int {
</span><span class='line'>       return x * y 
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>fun generateMultiply2(): (Int, Int) -&gt; Int {
</span><span class='line'>    return { x: Int, y: Int -&gt;
</span><span class='line'>        x* y 
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>fun generateMultiply3() = {x : Int, y : Int -&gt;
</span><span class='line'>    x + y
</span><span class='line'>    y + 3
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>fun subtract(x: Int) = fun(y: Int): Int {
</span><span class='line'>    return x - y
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Trailing lambda  又称 call suffix，类似ruby的模板方法在尾部输入函数</li>
<li>Higher-order functions，forEach里面有自动入参<code>it</code>，是item的缩写</li>
<li>Clousures 由此支持了currying和Memoization记忆数组，本质就是让函数也可以有<strong>状态</strong></li>
<li>fun或者lambda里更多地使用expressions而不是statements</li>
<li>tailrec用于性能优化递归函数，限制是只能是最后一句包含递归，本质上这是compiler技术提升的一种表现</li>
</ul>


<h3>线程和协程</h3>

<ul>
<li>昂贵的Thread，因为消耗更多的内存，有Thread Stack，还有CPU间的Context Switch</li>
<li>coroutines，kotlinx-coroutines-core提供了这种轻量级线程的实现，通过with+launch或者with+async的方式来实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>with(GlobalScope) {
</span><span class='line'>    launch {
</span><span class='line'>        delay(100)
</span><span class='line'>    } 
</span><span class='line'>}
</span><span class='line'>// with 在kotlin里让{}里的this自动指向入参，上面例子中就是GlobalScope，这个思路有点类似于decorator模式中举例的by repository。launch只是一个普通的method，但需要一个scope才能跑起来launch代表的coroutine</span></code></pre></td></tr></table></div></figure>


<ul>
<li>runBlocking和suspend</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fun main() {
</span><span class='line'>    runBlocking {
</span><span class='line'>        val job: Deferred&lt;UUID&gt; = fastUuidAsync()
</span><span class='line'>        println(job.await())
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>suspend fun main() {
</span><span class='line'>    val job: Deferred&lt;UUID&gt; = fastUuidAsync()
</span><span class='line'>    println(job.await())
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Dispatchers.Default和Dispatchers.IO等，协程实质依赖线程运行，dispatcher就是这些线程，可以作为入参提供给launch和async</li>
<li>Structured concurrency，coroutines套coroutines，父协程要等待子协程们完成才结束。子协程的异常会导致父协程终止，supervisorScope可以防止这个异常繁殖传递，coroutineScope方法也能做此限制</li>
</ul>


<h3>控制数据流</h3>

<p>FP+coroutines的设计原则：</p>

<ul>
<li>Responsive, Resilient(supple), Elastic, Message-driven</li>
<li>collections上的高阶函数，reduce的话有一个fold和reduce类似，但可以提供initial value，flatMap和flatten，后者更简洁一点，类似toList()不用输入lambda</li>
<li>sequences 同list最大的区别在于不像list被整个处理，而是会被一个一个送出去并行处理，一般而言效率优于List</li>
<li>Channels kotlin版本的BlockingQueue，用于底层通信，属于热队列，既已经发出的消息不会重放, produce可以制造一个channel，搭配这个channel上的consumeEach</li>
<li>Actor，封装了channel和coroutine，但在kotlin中处于临期的状态</li>
<li>Flows，冷队列，会把消息从头到尾再发给新的监听者，用于数据流但实际上也能通过配置改变这种默认的行为，搭配为emit和collect，flow有点像tcp，有更高级的主题，例如shareIn，Conflate以及限流相关的debounce，sample，distinctUntilChanged等功能函数，spring的projectreactor也提供了类似的库，但没有协程助力，要采用事件驱动的写法</li>
</ul>


<h3>并发相关的设计模式</h3>

<ul>
<li>Deferred Value, java的Future，kotlin的Deferred，一般从async中返回</li>
<li>Barrier, kotlin中是用几个await等待几个异步的事情都完成后再进行处理，java中的CountDown，CylicleBarrier也都是干这种事情的</li>
<li>Scheduler，任务的调度（如何执行）和执行什么分离，再kotlin是Dispatcher，在java是executors</li>
<li>Pipeline, 把一个复杂的任务拆成流水，这样可以多个线程或协程同时运行小任务，也是stream设计的要点</li>
<li>Fan-Out, 把一个大任务分散后发出去，同Pipeline的区别在于可能只是批处理分发，而pipeline有更强的单个操作的协作性</li>
<li>Fan-In，Out后的东西最终往往需要汇总后才有意义</li>
<li>Racing，和Barrier类似，但只要有一个有效就可以忽略其他等待，kotlin在这里使用了select，即多路复用</li>
<li>Mutex，类似java最经典的synchronize，通过lock unlock来同步竞态资源</li>
<li>Sidekick，小外挂，把一部分工作包出去，目前AI计算和NVIDIA的关系就是N卡其实就是Sidekick</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2022/04/23/wfh-yi-ge-ban-yue/">WFH一个半月</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2022-04-23T15:11:00+08:00" pubdate data-updated="true">Apr 23<span>rd</span>, 2022</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>二月初六龙抬头那天正好是周五，那天就WFH。不曾想，自从那天开始WFH，后面疫情日益严重。起初一个礼拜还只是我一人居家办公，
一周后中小学集体回家上网课，就变成我白天边上班边带娃。又过了一周，老婆单位也开始不能去办公大楼了。最后到了3月底，全上海都进入静态管理，也就是说大部分人是不能去写字楼上班了。
截止到现在，已经超过了一个半月，也不知道后续还会持续多久。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/12/30/2021-crvyang-che-cheng-ben-hui-zong/">2021 CRV养车成本汇总</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2021-12-30T10:55:00+08:00" pubdate data-updated="true">Dec 30<span>th</span>, 2021</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>具体比较：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 条目     </th>
<th style="text-align:left;"> 2021     </th>
<th style="text-align:left;">2020     </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">   停车费     </td>
<td style="text-align:left;">  18200      </td>
<td style="text-align:left;"> 9200+10000</td>
</tr>
<tr>
<td style="text-align:left;">   保险费     </td>
<td style="text-align:left;">   2960     </td>
<td style="text-align:left;">  3932</td>
</tr>
<tr>
<td style="text-align:left;">   油费     </td>
<td style="text-align:left;">     4214   </td>
<td style="text-align:left;">   4600</td>
</tr>
<tr>
<td style="text-align:left;">   高速     </td>
<td style="text-align:left;">     200   </td>
<td style="text-align:left;">   135</td>
</tr>
<tr>
<td style="text-align:left;">   保养     </td>
<td style="text-align:left;">     886   </td>
<td style="text-align:left;">  994+1000(电瓶)</td>
</tr>
<tr>
<td style="text-align:left;">   洗车     </td>
<td style="text-align:left;">     100   </td>
<td style="text-align:left;">   372</td>
</tr>
<tr>
<td style="text-align:left;">   上述合计     </td>
<td style="text-align:left;">    </td>
<td style="text-align:left;">      20233+10000</td>
</tr>
<tr>
<td style="text-align:left;">   里程     </td>
<td style="text-align:left;">      4616       </td>
<td style="text-align:left;">    6022</td>
</tr>
</tbody>
</table>


<p>今年又进行了大保养，换了变速箱和制动液的油，不过电瓶和轮胎都正常，所以这方面开销不大。
停车费和保险费都略减。</p>

<p>总体来讲，汽车方面的开销有所减少。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/10/26/the-kubernetes-book/">The Kubernetes Book</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2021-10-26T09:47:00+08:00" pubdate data-updated="true">Oct 26<span>th</span>, 2021</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The Kubernetes book, 购于Leanpub</p>

<h1>1&amp;2 Kubernetes 基础和操作</h1>

<h2>Control plane node (Masters, Heads)</h2>

<p>The API Server<br/>
   所有的入口</p>

<p>The cluster store(etcd)<br/>
    分布式数据库，3-5个拷贝，采用RAFT算法，由一个领袖说了算
    C优先于A，一旦不一致，就不能再更新了</p>

<p>The Controller manager<br/>
    Deployment, StatefulSet, ReplicaSet</p>

<p>The Scheduler<br/>
    检查Node的状况，给Node评分，以挑选合适的可以执行任务的Node</p>

<p>The cloud controller manager<br/>
    提供公有云服务的load-balancer到app的连接等</p>

<h2>Worker(Kubelet)</h2>

<p>Kubelet<br/>
    安装在主机上的代理，负责向heads汇报状态，并接受任务安排</p>

<p>Containerd<br/>
    从Docker抽象出来的接口，K8S已经不再直接支持Docker</p>

<p>kube-proxy<br/>
    运行在node上的网络组件，给每个node分配不同的docker内网，建立iptables表格完成路由功能</p>

<p>Kubernetes DNS<br/>
    每个Pod都有一个静态的Ip地址写了DNS服务，基于开源CoreDNS项目开发</p>

<h2>声明模式和渴望的状态</h2>

<ol>
<li>在manifest文件里声明目标状态（image，replicas数量，网络端口，如何更新）</li>
<li>Post给API服务（kubectl命令）</li>
<li>Kubernetes存入集群store（解析并分解成操作步骤入库）</li>
<li>Kubernetes实现目标状态(安排任务执行)</li>
<li>一个controller确保观察到的状态不会和目标状态不同(reconcile循环)</li>
</ol>


<h2>Pods</h2>

<p>A flock of birds 一群鸟 A pod of whales 一群鲸<br/>
所以pod就是一群dockers/containers</p>

<h2>Deployments</h2>

<p>一般不会直接部署pods，而是通过Controllers进行部署</p>

<h2>Service</h2>

<p>提供TCP UDP层面稳定的网络抽象</p>

<h1>3. 部署Kubernetes</h1>

<p>AWS: EKS, Azure: AKS, Google: GKE<br/>
腾讯: TKE, 阿里云: ACS（C是container）的缩写</p>

<p>可以在自己的机器上部署K8S作为练习：如docker Desktop，k3d, 开发可以用单机版的尝试</p>

<h2>kubectl</h2>

<p>~/.kube/config，中存放了命令行的操作配置</p>

<p>Clusters，Users和Contexts，前二者可以通过最后一个进行关联，表示用哪个用户的账号去操作哪个cluster</p>

<p><code>kubectl config current-context</code>用于查看当前活跃的context<br/>
<code>kubectl config use-context docker2</code> 用于调整当前活跃的context</p>

<h1>4. 用Pods工作</h1>

<ol>
<li>让资源共享：文件系统、同一个IP、共享内存、共享存储</li>
<li>一个pod中可以有多个containers，同一pod内的container可以通过localhost+不同的端口进行通信</li>
<li>通过Controller部署的pods才有高可用等特性支持</li>
<li>直接通过Pod manifest部署的pod，只有自生自灭</li>
</ol>


<p>Pod本身就是容器</p>

<h2>The pod network</h2>

<p>Pod的网络叫做pod network，是一种扁平的、各个pod可以彼此直接访问的组网。</p>

<h2>生命周期有长有短的pod</h2>

<p>long-lived: Deployments, StatefulSets, DaemonSets<br/>
short-lived: CronJobs, Jobs</p>

<p>长的多用于服务，短的多用于批量job。</p>

<h2>多Containers的几种花样</h2>

<p>Sidecar: 德国摩托车旁边的侧车；即一个container为主，一个为辅的模式。serice mesh里面常常用来对流量加密、暴露测量的数据<br/>
Adapter: sidecar的变种，比如把nginx的日志转变成普罗米修斯能解析的格式<br/>
Ambassador：也是变种，含义上讲更像是主container的使者<br/>
Init: 在拉起主app之前，执行一些辅助工作，通常只执行一次</p>

<p><code>kubectl apply -f pod.yml</code> 运行一个简单的pod，下面两个命令用于查询pod及其内容器的状态<br/>
<code>kubectl describe pods hello-pod</code><br/>
<code>kubectl get pods  hello-pod  -o wide</code></p>

<p>普通的执行命令 <code>kubectl exec hello-pod -- ps aux</code><br/>
获取pod内shell的命令 <code>kubectl exec -it hello-pod -- sh</code>, 注意需要加上<code>it</code></p>

<h1>5. Namespace</h1>

<p>查看命名空间 <code>kubectl get namespaces</code>  可以缩写为<code>ns</code></p>

<p>用kubectl可以命令式创建ns，用yaml文档可以声明式创建<br/>
<code>kubectl create ns hydra</code><br/>
<code>kubectl apply -f shields-ns.yml</code></p>

<p>切换默认的ns <code>kubectl config set-context --current --namespace ss</code></p>

<p>声明式的清除 <code>kubectl delete -f shield-app.yml</code></p>

<h1>6. Kubernetes部署</h1>

<p>Workload apis: Deployments, DaemonSets, StatefulSets</p>

<p>Deployments是aggregation root，内部其实还有ReplicaSet， 通过ReplicaSet来操作Pods</p>

<p>Reconcile：补锅，补偿，使得现实变成目标</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">piVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">apps/v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Deployment</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">hello-deploy</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">replicas</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10</span>
</span><span class='line'>  <span class="l-Scalar-Plain">selector</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">matchLabels</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">app</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">hello-world</span>
</span><span class='line'>  <span class="l-Scalar-Plain">minReadySeconds</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10</span>
</span><span class='line'>  <span class="l-Scalar-Plain">strategy</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">RollingUpdate</span>
</span><span class='line'>    <span class="l-Scalar-Plain">rollingUpdate</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">maxUnavailable</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1</span>
</span><span class='line'>      <span class="l-Scalar-Plain">maxSurge</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1</span>
</span><span class='line'>  <span class="l-Scalar-Plain">template</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">labels</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">app</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">hello-world</span>
</span><span class='line'>    <span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">hello-pod</span>
</span><span class='line'>        <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">nigelpoulton/k8sbook:latest</span>
</span><span class='line'>        <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">containerPort</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">8080</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>.spec.selector</code>中的label选择了template中的app，注意label Selectors</p>

<p><code>ubectl get deploy hello-deploy</code><br/>
<code>kubectl scale deploy hello-deploy --replicas 5</code></p>

<p>rollback， clean-up</p>

<h1>7. Service</h1>

<ol>
<li>Service是一个K8S对象</li>
<li>Service有稳定的ip地址(a cluster ip)、dns名字以及port口</li>
<li>利用labels和selectors去动态地选择pods以传递流量</li>
</ol>


<p>从外部访问的方法：1. NodePort， 2. LoadBalancer</p>

<p>使用DNS服务作为服务发现的核心。Service名称会自动注册到DNS集群中，每个pod及其container都预先配置了dns集群的配置，以解决Service Name 到 ClusterIP之间的映射</p>

<h1>8. Ingress</h1>

<p>Ingress属于七层交换的概念，可以通过域名或路径等组合来转发请求</p>

<p>NodePorts的缺点： 使用的port偏大，30000-32767<br/>
LoadBalancer缺点： 需要和云的load-balancer 1-to-1 对应，开销容易很大<br/>
Ingress可以在只有一个云load-balancer的情况下完成多个服务的路由</p>

<p>不过，如果使用一个service mesh，可能Ingress的作用就不大了。</p>

<p>Ingress也是一种controller，只是大部分不是内建的。</p>

<p>可以使用helm创建nginx-ingress</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx</span>
</span><span class='line'><span class="l-Scalar-Plain">helm repo update</span>
</span><span class='line'><span class="l-Scalar-Plain">helm install ingress-nginx ingress-nginx/ingress-nginx --namespace ss</span>
</span><span class='line'><span class="l-Scalar-Plain">kubectl get pods -n ss -o wide</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">ingress-nginx-controller-5c8d66c76d-2kq2f   1/1     Running   0          49m   10.244.2.34   master-node   &lt;none&gt;           &lt;none&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">kubectl get svc</span>
</span><span class='line'><span class="l-Scalar-Plain">NAME                                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span>
</span><span class='line'><span class="l-Scalar-Plain">ingress-nginx-controller             LoadBalancer   10.108.112.4    &lt;pending&gt;     80:32003/TCP,443:30330/TCP   50m</span>
</span></code></pre></td></tr></table></div></figure>


<p>但因为是自建的kubeadm，所以没有云原生的直接load-balance的支持，但可以通过32003端口对服务进行访问。</p>

<h1>9. 服务发现详解</h1>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">kubectl get pods -n kube-system  -o wide</span>
</span><span class='line'><span class="l-Scalar-Plain">NAME                                           READY   STATUS    RESTARTS      AGE   IP             NODE                   NOMINATED NODE   READINESS GATES</span>
</span><span class='line'><span class="l-Scalar-Plain">coredns-78fcd69978-kb5td                       1/1     Running   1 (8d ago)    59d   10.244.0.4     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;</span>
</span><span class='line'><span class="l-Scalar-Plain">coredns-78fcd69978-l6m5g                       1/1     Running   1 (8d ago)    59d   10.244.0.5     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>control plane上有dns集群</p>

<p>svc部署后会分配一个vip，也就是clusterIp；因为svc name最终会进入dns服务，所以这也是svc的命名规则要求和dns域名一致的根本原因</p>

<p>Kube-proxy会完成对Endpoints的监控和转发调整。现代版本的linux普遍使用IPVS，老的使用iptables。</p>

<p>clusterIp是一个不存在的IP，所以container传给node，node传给它的gateway（node的kernel，IPVS或Iptables），由kube-proxy负责对ClusterIp的重定向。
IPVS是L4 load-balancer，扩展的性能更优越。</p>

<p>服务发现和namespace</p>

<p><code>&lt;object-name&gt;.&lt;namespace&gt;.svc.cluster.local</code></p>

<p><code>kubectl get all -n dev</code> 可以同时列出 svc pods</p>

<h1>10. Storage</h1>

<p>Storage采用的CSI plugin的机制。</p>

<p>SC - StorageClass 定义存储的硬件<br/>
PVC - 变成PV的请求，也是Pod可以使用的存储  <br/>
PV - SC检测到PVC后，会变成PV</p>

<ul>
<li>PVC里的Access mode:

<ul>
<li>ReadWriteOnce(RWO)传统的一块硬盘</li>
<li>ReadWriteMany(RWM) NFS这种支持多个加载</li>
<li>ReadOnlyMany(ROM)  可被多少只读</li>
</ul>
</li>
</ul>


<p>PV只能按一种模式打开</p>

<p><code>kubectl get sc</code></p>

<p>解除后数据是否删除的策略：1. Delete 2. Retain<br/>
Sc中的VolumeBindingModo: 1. Immediate 2. WaitingForFirstConsumer(Pod)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">apiVersion</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">v1</span>
</span><span class='line'><span class="l-Scalar-Plain">kind</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Pod</span>
</span><span class='line'><span class="l-Scalar-Plain">metadata</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">volpod</span>
</span><span class='line'><span class="l-Scalar-Plain">spec</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">volumes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">data</span>
</span><span class='line'>    <span class="l-Scalar-Plain">persistentVolumeClaim</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">claimName</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">pvc-prem</span>
</span><span class='line'>  <span class="l-Scalar-Plain">containers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">ubuntu-ctr</span>
</span><span class='line'>    <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">ubuntu:latest</span>
</span><span class='line'>    <span class="l-Scalar-Plain">command</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">/bin/bash</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="s">&quot;-c&quot;</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="s">&quot;sleep</span><span class="nv"> </span><span class="s">60m&quot;</span>
</span><span class='line'>    <span class="l-Scalar-Plain">volumeMounts</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">mountPath</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/data</span>
</span><span class='line'>      <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">data</span>
</span></code></pre></td></tr></table></div></figure>


<h1>11. ConfigMaps and Secrets</h1>

<p>ConfigMaps是键值对，value可以是一个简单的值，也可以是一整个配置文件。<br/>
注入container有几种方式：1. 环境变量 2. 启动的命令 3. volume中的文件<br/>
env var； cmd； vol</p>

<p><code>kubectl create configmap</code></p>

<p>vol最大的优势是一旦修改了configMap，可以在container的mount位置立刻看见修改。而两位两个必须重启容器。即Vol的注入是动态的，env的注入是静态的。</p>

<p>Secret只是以base64的形势存放起来</p>

<h1>12. StatefulSets</h1>

<p>与Deployment相比的差异：<br/>
1. 可预知的持久的pod名字<br/>
2. 可预知的持久的DNS主机名字<br/>
3. 可预知的持久度vol绑定</p>

<p>pod生成的规则：<StatefuleSetName>-<Integer>，而且是按顺序依次启动，完成前一个，才启动后一个。</p>

<p>Stateful controllers自己直接处理治愈和扩容，而不是假手ReplicaSet</p>

<h2>headless service and StatefulSet&#8217;s governing service</h2>

<p>headless service就是clusterIP为空的service，搭配StatuefulSet，就会产生独立的每个pod的dns名称。app的调用也会基于具体的pod 名称。</p>

<p><code>volumeClaimTemplates</code>用于给每个stateful pod创建动态PVC。</p>

<p>独立pod的dns命名规则为<object-name>.<service-name>.<namespace>.svc.cluster.local</p>

<p>如果是pod退出，那么StatefulSet可以很容易地重新创建一个替代的pod。但如果是node不正常，则需要手工干预。</p>

<h1>13. API 安全和RBAC</h1>

<p>user,gourp, Service acct -> API server -> authN -> authZ -> Admission control</p>

<p>Kubernetes没有自己的identity database，主要通过和其他auth模块集成（plug-in）的方式来实现authN。<br/>
比如client certs，webhooks，IAM（Identity Access Management)</p>

<p>K8S的authZ只有allow没有deny，因为默认全部都是deny。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">rules</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">apiGroups</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;apps&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">resources</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;deployments&quot;</span><span class="p-Indicator">]</span>
</span><span class='line'>    <span class="l-Scalar-Plain">verbs</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="s">&quot;get&quot;</span><span class="p-Indicator">,</span> <span class="s">&quot;watch&quot;</span><span class="p-Indicator">,</span> <span class="s">&quot;list&quot;</span><span class="p-Indicator">]</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>*</code>意味着全部授权</p>

<p>4个RBAC对象</p>

<ul>
<li>Roles</li>
<li>ClusterRoles</li>
<li>RoleBindings</li>
<li>ClusterRoleBindings</li>
</ul>


<p>顾名思义，可以使用的namespace是不同的。需要注意的是，ClusterRoles经常和RoleBindings搭配使用。</p>

<p>Admission controller有很多个，实际主要负责批准相应的请求。</p>

<h1>14. The Kubernetes API</h1>

<p>JSON + Protobuf支持，</p>

<p>可以自己定义并扩展API</p>

<h1>15. Threat和K8S</h1>

<p>STRIDE 模型</p>

<p>Spoofing欺骗:<br/>
  - 通信层面的安全TLS<br/>
  - 限制pod和API server的通信，token的失效期等等</p>

<p>Tampering篡改:<br/>
  - 组件的篡改：etcd，api server，controller，scheduler，kubelet，镜像运行时，镜像文件等<br/>
  - 运行的pod修改</p>

<p>Repudiation否认:<br/>
  - 中央化的收集各个组件的审计日志</p>

<p>Information Disclosure 信息泄露:<br/>
  - KMS和HSM是实现key和数据在节点上分离</p>

<p>Denial of Service(DOS):<br/>
  - HA<br/>
  - WAF</p>

<p>Elevation of privilege:</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/10/04/java-8-9-10-in-action/">Java 8 9 10 in Action</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2021-10-04T21:22:00+08:00" pubdate data-updated="true">Oct 4<span>th</span>, 2021</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>第一章</h1>

<p>第一作者写作时是剑桥的在读博士，同时第三作者是他的博士生导师。第二作者是Redhat的Java 8普及牛人。</p>

<p>Brian Goetz 把函数式编程内容加入Java，他也是java的架构师或者说设计师。</p>

<p>本书涉及了Stream, lambda, Optional, CompletableFuture, RxJava, Akka(Java 9)</p>

<p>Function变成一等公民，可以在运行时被传来传去。<br/>
method reference :: syntax<br/>
lambdas</p>

<p>原本<code>filter</code>等功能可以添加在Collections类中。但为了匹配多核时代，引入了streams，对并行(parallelStream)和单行stream进行了区分。</p>

<p><code>Default Method</code>的加入是为了让已经存在的List的实现类可以不需要自己单独去实现stream()这种方法，但这让java具备了多继承的能力。因为default method的加入，等于接口可以变成抽象类。</p>

<h1>第二章 行为参数化传递的方式</h1>

<p>lambda也是一个对象，也可以用工厂方法来构造</p>

<p>以前传行为（策略模式）是需要构造一系列的接口和类，实现共同的接口，因为只能传入对象。<br/>
Java匿名类：允许你声明和初始化一个类在同一时刻。<br/>
lambda和上面的特性一样，但更加精简</p>

<p>4个实际经常使用的匿名类接口：<code>Comparator</code>，<code>Runnable</code>，<code>Callable</code>，<code>EventHandler</code></p>

<h1>第三章 Lambda</h1>

<p>lambda可在Functional Interface(例如Predicate<T>）处被传入</p>

<p><strong>Functional Inteface就是有且只有一个抽象方法的接口。</strong><br/>
lambda就是一个Functional Interface的抽象方法的实现实例<br/>
<code>@FunctionalInterface</code> 对于Functional Interface的标注，表示有且仅有一个抽象接口。</p>

<p>FunctionalInterface就是lambda的引用类型，此时func也就变成了一个对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&lt;---&gt;</span> <span class="n">T</span> <span class="o">--&gt;</span> <span class="kt">boolean</span>
</span><span class='line'><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&lt;---&gt;</span> <span class="n">T</span><span class="o">-&gt;</span> <span class="kt">void</span>
</span><span class='line'><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">&lt;---&gt;</span> <span class="n">T</span> <span class="o">-&gt;</span> <span class="n">R</span>
</span><span class='line'><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&lt;---&gt;</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">T</span>
</span><span class='line'><span class="n">Runnable</span> <span class="o">&lt;---&gt;</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为boxing的性能原因，上面还有一系列Int Long 之类的变种</p>

<h2>Target typing</h2>

<p>先根据被使用的FI类型，比如<code>filter</code>是<code>Predicate</code>，那么意味着需要一个输入为<code>T</code>返回为<code>boolean</code>的lambda。<br/>
同时，因为这个接口里面的method名字lambda并不会涉及，实际上叫什么也无所谓，所以要求FI只能有一个抽象method。这样的话，method具体叫什么就无所谓了，只要方法签名对的上，实现中甚至可以单独生成一个匿名类。</p>

<p>local variable 和instance variable在lambda中的异同，因为他们在JVM里面的位置不同，local var是在本地func的stack里，实例变量则在Heap中。所以local var必须加上final或者实际上只被赋值一次。</p>

<h2>3种Method Reference</h2>

<ol>
<li>静态方法 <code>Integer::parseInt</code></li>
<li>实例方法 <code>String::length</code></li>
<li>已存在对象的实例方法 <code>expensiveTransaction::insert</code></li>
</ol>


<p>上面的方法都可以传入多个参数，但同时也不需要使用()，毕竟只是声明需要使用这个method</p>

<p>构造方法作为一种特殊的method，也能成为method Reference</p>

<h2>FI中的其他接口（组合lambda表达式）</h2>

<p>适用组合模式，其他接口都是<code>default</code>类型的接口</p>

<p><code>Comparator: reversed, thenComparing</code><br/>
<code>Predicate: and, or, not</code>  <br/>
<code>Function: andThen, compose</code>, 注意二者的区别，前者是管道，后者是被compose的内容先执行</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'><span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">andThen</span><span class="o">(</span><span class="n">g</span><span class="o">);</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;h(1): &quot;</span> <span class="o">+</span> <span class="n">h</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<h1>第四章 Stream</h1>

<p><code>Collection</code>的弱点：1. 不能像SQL那样组合查询（declarative way 声明式查询） 2. 集合太大可能无法处理</p>

<p>民间自发的：<code>Guava</code>，<code>Apache</code>，<code>lambdaj</code>（本书第二作者的作品）</p>

<p><strong>Stream</strong>: Declarative, Composable, Parallelizable</p>

<p>Compute on demand, a lazily constructed collection</p>

<p>中间的操作：<code>filter</code>，<code>map</code>，<code>limit</code>， <code>sorted</code>，<code>distinct</code><br/>
Terminal操作：<code>collect</code>，<code>count</code>，<code>forEach</code></p>

<h1>第五章 Streams 2</h1>

<h2>操作</h2>

<p><strong>Filtering</strong>：<code>filter</code>, <code>distinct</code>, <code>takeWhile</code>(java 9), <code>dropWhile</code>(Java 9), <code>limit</code>, <code>skip</code><br/>
<strong>Mapping</strong>: <code>map</code>, <code>flatMap</code>(入参也是一个stream）<br/>
<strong>Finding</strong>：<code>anyMatch</code>，<code>allMatch</code>，<code>noneMatch</code>，<br/>
               <code>findAny</code>（返回的是Optional，后面接ifPresent），<code>findFirst</code>，<code>findAny</code>和<code>findFirst</code>的功能基本相同，区别在于并行的时候<code>findFirst</code>更加严格<br/>
<strong>Reducing</strong>（Terminal）：<code>reduce(0, Integer::sum)</code>, <code>reduce(Integer::sum</code>）但这个是返回<code>Optional</code>，因为可能stream里面没有元素<br/>
    <code>reduce</code>之前可map成其他数字或对象</p>

<p>Stateful和Stateless的操作，reduce是stateful的操作，但影响并不大。但是sorted，reverse，distinct就是需要空间很大的stateful操作了。</p>

<p>对于<code>IntStream</code>，需要使用boxed让其回到普通stream，或者使用mapToObj，而<code>rangeClose</code>可以构造一个整型int stream出来</p>

<h2>创建streams</h2>

<p><code>Stream.ofNullable(value)</code>，<code>File.lines</code>，<code>Arrays.stream(numbers)</code>，<code>Stream.iterate</code></p>

<h1>第六章 Collectiong 操作（Terminal的一种）</h1>

<p>返回一个值<br/>
返回一群元素<br/>
分区域的一群元素</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">count</span><span class="o">()</span> <span class="o">&lt;---&gt;</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">counting</span><span class="o">()</span>
</span><span class='line'><span class="n">summingInt</span><span class="o">,</span> <span class="n">summarizingInt</span><span class="o">,</span>
</span><span class='line'><span class="n">joining</span><span class="o">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>reducing</code>  &#8211;> Collector的reduce，更专业且支持并行操作，reducin接受<T>操作以及&lt;T, T,  T>两种函数接口</p>

<p><code>groupingBy</code>
的第二个参数可以继续传入groupingBy，实际上所有的collector都可以作为第二个参数传入。
默认的groupingBy其实是<code>groupingBy(f, toList())</code></p>

<p><code>collectingAndThen</code>也能传给groupingBy，在有些情况下可以去除里面返回的<code>Optional</code>，<code>maxBy(comparingInt(Dish::getCalories)), Optional::get)));</code>
<code>mapping</code>也经常搭配<code>groupingBy</code>使用，第一个参数是做转换，第二个参数是对转换后的元素做terminal操作。</p>

<p><code>partitioningBy</code>是一种特殊的，只有两个值（true or false）的<code>groupingBy</code></p>

<h2>Collector接口</h2>

<p>接口由4个function+1个特性枚举构成</p>

<p>Collector&lt;T, ?, List<T>> toList() {
        return new CollectorImpl&lt;>(ArrayList::new, List::add,
                                   (left, right) -> { left.addAll(right); return left; },
                                   CH_ID);
    }</p>

<p> static class CollectorImpl&lt;T, A, R> implements Collector&lt;T, A, R> {}</p>

<p>特性枚举：<br/>
1. UNORDERED<br/>
2. CONCURRENT<br/>
3. IDENTITY_FINISH</p>

<p>第2个必须在第1个的基础上才起作用，第三个表明finisher不需要做什么事情</p>

<p>Collector本身也提供了蓝图或者说框架，让开发更简单</p>

<h1>第七章 并行处理</h1>

<p>sequential 和 parallel，但只有最后一个被声明的生效</p>

<p>RecursiveTask<Long>，实现里面的compute() 方法, <code>new ForkJoinPool().invoke(task)</code></p>

<p><code>Spliterator</code>, 并行版的Iterator</p>

<h1>第八章 Collection API 加强</h1>

<p>Java 8:  <code>Arrays.asList</code><br/>
Java 9: <code>List.of</code></p>

<h1>第九章 重构、测试与调试</h1>

<p>lambda在很多情况下可以替换模板方法，以及相当一部分原先需要使用oo来实现的策略模式</p>

<p>多阶函数可以很好的完成职责链的工作，例如<code>thenCombine</code>，<code>thenComparing</code>，<code>and</code>，<code>or</code>等等</p>

<p><code>peek</code>可用于打印stream的内容，调试打印日志时比较有用</p>

<h1>第十章 DSL和lambdas</h1>

<p>用builder模式来实现复杂的构造！！！在builder中实现DSL。</p>

<h1>第十一章 Optional</h1>

<p><code>Optional</code>在定义domain的时候，明显表达了给属性可能为空的事实。<br/>
对于不会为空的字段，则不需要加上Optional。<br/>
用<code>map</code>可以得到里面的值，用<code>flatMap</code>可以脱去可能得到的返回也是<code>Optional</code>的情况</p>

<p>unwrapping的几个方法：<br/>
<code>get()</code>，不值得用，和null检查差不多。<br/>
<code>orElseGet()</code>， lazy 版本，最值得推荐<br/>
<code>orElseThrow()</code></p>

<p><code>map</code>, <code>flatMap</code>其实都是<code>Optional</code>也有的方法，默认返回会携带<code>Optional</code>，用于处理值为空的情况。</p>

<h1>第十二章 New Date and Time Api</h1>

<p>Java老的Date API的问题：<br/>
1. Date的命名不清，月份从0开始，年份从1900开始，没有什么时区的概念<br/>
2. 第二版出了Calendar，年份问题解决，但月份还是从0开始，两个并行带来了困扰<br/>
3. DateFormat不是线程安全的类<br/>
4. Calendar和Date都不是Value Object</p>

<p>新的API主要抄袭了Joda-Time的内容</p>

<p><code>LocalDate</code>，<code>LocalTime</code>，<code>LocalDateTime</code>由前两个组成，甚至localDate和localTime的实例中有<code>createLocalDateTime</code>的工厂方法  <br/>
<code>TemporaField</code>是接口，<code>ChronoField</code>是枚举的实现</p>

<p><code>Instant.now</code></p>

<p><code>Duration</code>用于表示纳秒/毫秒级别的差异，可以用<code>between</code>工厂方法创建<br/>
<code>Period</code> 用于表示天数之间的，可以用于<code>localDate</code>之间的差异<br/>
<code>TemporalAdjusters</code>的静态方法，提供了很多传给<code>with</code>方法以生成新日期对象的调节对象</p>

<p>可以选择实现自己的<code>TemporalAdjuster</code>接口或lambda</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">nextWorkDay</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>LocalDate.parse</code>可以输入<code>DateTimeFormatter</code>，打印时直接<code>date.format()</code>里面输入需要的formatter</p>

<p><code>ZoneRules</code>，<code>ZoneId</code>，<code>ZoneId</code>混合<code>LocalDateTime</code>等可以新生成`ZonedDateTime</p>

<p><code>ZoneOffset</code>是ZoneId的子类</p>

<h1>第十三章 Default Methods</h1>

<p>为了兼容性，为了可以让API不断演进。</p>

<p>接口可以<code>extends</code>接口，实现多个默认default，会带来多继承的问题。<br/>
解决规则：<strong>Ambiguous的情况下会提示报错</strong>，要求用户再次选择。其他情况下：
1. class里实现的优先级总是高于Interface；
2. 子interface的优先级高于被继承的interface</p>

<p><code>X.super.m(..)</code>的新syntax用于解决Ambiguous的情况。</p>

<p>在子interface中定义一个抽象接口，那么实现该子interface的类就必须实现此方法，尽管在父interface里面可能存在default的实现。</p>

<h1>第十四章 Module</h1>

<p>Java的代码组织层级：1. class 2. package 3. jar，只有class拥有可见性的控制颗粒度，package和jar没有控制</p>

<p>多了require和export用于定义package的开放状态和依赖情况，这些信息位于<code>module-info.java</code>中</p>

<p>java运行时增加了参数 <code>--module-path</code> 可以在后面指定模块对应的jar包</p>

<h1>第十五章 并发（Concurrency）和并行（Parallelism）</h1>

<p>并发是事件类，就是一事未必，再起一事，然后等待几件事情同时得到结果。<br/>
并行是起多个任务同时交给多个core去做。<br/>
GC里也有类似的概念，并发GC意味着GC和应用程序同时进行，并行意味着应用程序暂停但开启多个线程做GC。</p>

<p><code>t1.join()</code>在主线程里面等待t1结束；<br/>
<code>Future&lt;Integer&gt; x</code>, <code>x.get()</code>会blocking等待线程运行结束</p>

<p>Java的新异步方案：<br/>
1. Java 8 中引入的<code>CompletableFuture</code>
2. Java 9 中引入的<code>Flow</code></p>

<p><code>CompletableFutur</code>e同时实现了组合接口，从而拥有了<code>thenCombil</code>e的能力。<code>executorService.submit</code>直接返回的就是<code>Future</code>，但使用<code>CompletableFuture</code>并不用再<code>submit</code>后取得返回，而是自己<code>new</code>了<code>CompletableFuture</code>后使用<code>get</code>。提交时也变成<code>executorService.submit(() -&gt; a.complete(f(x)))</code>;实际往往可以使用工厂方法创建。</p>

<p>订阅模式的pressure和<strong>backpressure</strong>，后者主要用于订阅者确保压力不会太大</p>

<h1>第十六章 CompletableFuture：可组合的异步编程</h1>

<p>主要是为了实现<code>future</code>的组合，其次也是因为Java 8提供了新的机制。Doug Lea大爷出品。</p>

<p><code>CompletableFuture.supplyAsync</code> 工厂方法，入参为Supplier接口，提供一个Callable的返回内容<br/>
所以一般不需要先new一个CompletableFuture再调用complete方法。<br/>
<code>CompletableFuture::join</code>方法可以等待多个join方法执行完成</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">N</span><span class="o">(</span><span class="n">threads</span><span class="o">)</span> <span class="o">=</span> <span class="n">N</span><span class="o">(</span><span class="n">CPU</span><span class="o">)*</span><span class="n">U</span><span class="o">(</span><span class="n">CPU</span><span class="o">)*(</span><span class="mi">1</span><span class="o">+</span><span class="n">W</span><span class="o">/</span><span class="n">C</span><span class="o">),</span> <span class="n">waitTime</span><span class="o">/</span><span class="n">computeTime</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>.thenApply</code>, <code>.thenCompose</code>，有些结尾如<code>thenComposeAsync</code>，意味着可以不在同一个线程里被执行.<br/>
<code>.thenCombine</code>则是互相不依赖的</p>

<p>Java 9 加入的timeOut特性：orTimeOut（报告异常），completeOnTimeout（添加默认的返回值）</p>

<p>第十七章 Reactive Programming</p>

<p><code>java.util.concurrent.Flow</code>，该接口被众多第三方库实现：<br/>
1. Akka（Lightbend）<br/>
2. Reactor(Pivotal)<br/>
3. RxJava(Netflix)<br/>
4. Vert.x(Red Hat)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Publisher</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">Subscriber</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">S</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Subscriber</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Subscription</span> <span class="n">s</span><span class="o">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">();</span>   
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>onSubscribe onNext* (onError | onComplete)?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Subscription</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">request</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">cancel</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Processor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">Publisher</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="o">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>第十八章 函数式考虑</h1>

<p>Tail-recursive的递归可以优化性能，不过java不支持。这种方法的特点是函数的最后就是自己调用自己。</p>

<h1>第十九章 FP技巧</h1>

<p>Higher-order functions：传递函数作为参数的函数<br/>
Curring：可以分批应用参数的函数，其实就是把值先保存在函数体中<br/>
数据结构存储：每次新建一个（批）对象</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/08/19/apollo-config/">Apollo Config</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2021-08-19T17:30:00+08:00" pubdate data-updated="true">Aug 19<span>th</span>, 2021</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>配置项的管理始终是一个很头疼的问题。虽然磕磕绊绊总能凑合着过，但确实一直不太优雅，甚至容易出错。
人多的情况下，优雅是很难的，还是考虑怎么能减少损耗吧。所以抽空看了看Apollo的东西。</p>

<blockquote><p>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。</p></blockquote>

<p>也支持热更新、版本控制、分组等比较实用的特性，据说还能适应复杂的流程治理要求。简单适用了一下，确实不负盛名。</p>

<h3>一. 安装并启动Apollo</h3>

<p>因为是试用，目前使用的是单机版的Apollo，后续可能会进一步调研一下高可用版的发布。</p>

<p>下载 <code>https://github.com/apolloconfig/apollo-build-scripts.git</code> ,  修改<code>demo.sh</code>里面的数据库配置信息和config server信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> apollo_config_db_url="jdbc:mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8&serverTimezone=Asia/Shanghai"
</span><span class='line'>-apollo_config_db_username=root
</span><span class='line'>-apollo_config_db_password=
</span><span class='line'>
</span><span class='line'> # apollo portal db info
</span><span class='line'> apollo_portal_db_url="jdbc:mysql://localhost:3306/ApolloPortalDB?characterEncoding=utf8&serverTimezone=Asia/Shanghai"
</span><span class='line'>-apollo_portal_db_username=root
</span><span class='line'>-apollo_portal_db_password=
</span><span class='line'>
</span><span class='line'>-config_server_url=http://localhost:8080
</span><span class='line'>-admin_server_url=http://localhost:8090
</span><span class='line'> eureka_service_url=$config_server_url/eureka/
</span><span class='line'>-portal_url=http://localhost:8070</span></code></pre></td></tr></table></div></figure>


<p>config server就是未来的meta server，portal就是管理界面。</p>

<h3>二. Java端的配置</h3>

<p>对于基于Sprint Boot的应用而言，最简单和顺利的方式是在bootstrap.yml里面。操作步骤如下</p>

<ol>
<li>加入依赖 <code>   implementation group: 'com.ctrip.framework.apollo', name: 'apollo-client', version: '1.8.0'</code></li>
<li>除去原先对config的依赖 <code>compile('org.springframework.cloud:spring-cloud-starter-config')</code>, 删除整个application.yml文件</li>
<li>删除application.yml文件，并把内容转移到apollo里面</li>
<li>在bootstart.yml里面替换下面的文件</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apollo:
</span><span class='line'>  bootstrap:
</span><span class='line'>    enabled: true
</span><span class='line'>    namespaces: application,application.yml
</span><span class='line'>  meta: http://xxxx:8080
</span><span class='line'>app:
</span><span class='line'>  id: xxxxxx-compare-monit
</span></code></pre></td></tr></table></div></figure>


<p>enabled表示启用apollo读取配置，namespaces是给出了需要拉取的namespace，默认只有application一个，如果是自己添加的yml，则需要按上面的配置加一个。
meta就是config server的地址。app.id表示了应用的身份，需要和apollo的对应起来。</p>

<p>如果再portal侧重新发布配置项，可以看见下面的日志</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INFO 69947 --- [Apollo-Config-1] c.f.a.s.p.AutoUpdateConfigChangeListener : Auto update apollo changed value successfully, new value: 222222, key: bcmonit.xxxxxKey, beanName: xxxxxxProperties, field: com.xxxxx.address.util.xxxxxProperties.xxxxxKey
</span></code></pre></td></tr></table></div></figure>


<p>更多的内容可以参考官网的设计文档，对apollo架构的介绍非常到位。</p>

<p><a href="https://www.apolloconfig.com/#/zh/design/apollo-design">Apollo官网设计文档</a></p>

<h3>三. K8S 部署</h3>

<p>首先，要有一个K8S集群，可以参考 https://phoenixnap.com/kb/install-kubernetes-on-ubuntu
来进行操作。但一般会需要trouble shotting，比较好的工具是通过<code>journalctl -xeu kubelet</code> 查看日志来定位问题，然后一一解决</p>

<ul>
<li>安装docker</li>
<li>安装kubeadm kubelet kubectl

<ul>
<li>用apt-mark hold把上面几个组件的版本<strong>定</strong>住</li>
</ul>
</li>
<li>Master

<ul>
<li>用kubeadm init &#8211;pod-network-cidr=10.244.0.0/16创建带网络信息的初始化</li>
<li>用kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml部署虚拟网络</li>
<li>查看pods的情况 kubectl get pods &#8211;all-namespaces</li>
</ul>
</li>
<li>Workder

<ul>
<li>用kubeadm join &#8211;discovery-token abcdef.1234567890abcdef &#8211;discovery-token-ca-cert-hash sha256:1234..cdef 1.2.3.4:6443 加入k8s集群。</li>
<li>其中的token可以通过kubeadmin token list查看，通过kubeadmin token create &#8211;ttl 0创建，sha256是证书，不会失效</li>
<li>通过kubectl get nodes查看节点状态</li>
</ul>
</li>
<li>安装服务或应用

<ul>
<li>使用helm</li>
<li>使用kubectl apply</li>
</ul>
</li>
</ul>


<p>其次，安装helm，这是一个k8s的包管理工具:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl https://baltocdn.com/helm/signing.asc | sudo apt-key add -
</span><span class='line'>sudo apt-get install apt-transport-https --yes
</span><span class='line'>echo "deb https://baltocdn.com/helm/stable/debian/ all main" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list
</span><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get install helm</span></code></pre></td></tr></table></div></figure>


<p>查看安装效果</p>

<p><code>kubectl get pods --all-namespaces -o wide</code> ，这个可以输出实际跑在各节点上的效果</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AMESPACE     NAME                                                       READY   STATUS              RESTARTS   AGE     IP             NODE                   NOMINATED NODE   READINESS GATES
</span><span class='line'>default       apollo-service-dev-apollo-adminservice-566996fd98-mkdgm    1/1     Running             0          5d19h   10.244.2.3     master-node            &lt;none&gt;           &lt;none&gt;
</span><span class='line'>default       apollo-service-dev-apollo-configservice-7f955f6f66-x2mjw   0/1     ContainerCreating   0          5d19h   &lt;none&gt;         master-node            &lt;none&gt;           &lt;none&gt;
</span><span class='line'>default       my-nginx-5b56ccd65f-4rngp                                  1/1     Running             0          3h8m    10.244.2.2     master-node            &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   coredns-78fcd69978-kb5td                                   1/1     Running             0          5d20h   10.244.0.3     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   coredns-78fcd69978-l6m5g                                   1/1     Running             0          5d20h   10.244.0.2     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   etcd-office-wallet-dev-17                                  1/1     Running             0          5d20h   172.17.3.4     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   kube-apiserver-office-wallet-dev-17                        1/1     Running             0          5d20h   172.17.3.4     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   kube-controller-manager-office-wallet-dev-17               1/1     Running             0          5d20h   172.17.3.4     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   kube-flannel-ds-mbvzp                                      1/1     Running             0          18m     172.17.3.186   master-node            &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   kube-flannel-ds-x75sk                                      1/1     Running             0          5d20h   172.17.3.4     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   kube-proxy-n6q7x                                           1/1     Running             0          18m     172.17.3.186   master-node            &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   kube-proxy-ph8s5                                           1/1     Running             0          5d20h   172.17.3.4     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;
</span><span class='line'>kube-system   kube-scheduler-office-wallet-dev-17                        1/1     Running             0          5d20h   172.17.3.4     office-wallet-dev-17   &lt;none&gt;           &lt;none&gt;</span></code></pre></td></tr></table></div></figure>


<h3>Helm 和 kubectl apply的区别</h3>

<p>默认kube提供的安装服务方法是<code>kubectl apply -f ./run-my-nginx.yaml</code>，适用于应用比较少的情况。如果应用很多，那么helm就可以帮上忙了。</p>

<p>https://www.apolloconfig.com/#/zh/deployment/distributed-deployment-guide?id=_24-kubernetes%e9%83%a8%e7%bd%b2</p>

<p>groovy for gradle:</p>

<p>https://docs.gradle.org/current/dsl/org.gradle.api.Task.html</p>

<p>https://docs.gradle.org/current/userguide/tutorial_using_tasks.html</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/08/09/mysqlde-ku-biao-rong-liang-cha-xun/">Mysql的库表容量查询</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2021-08-09T17:52:00+08:00" pubdate data-updated="true">Aug 9<span>th</span>, 2021</time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>select  
</span><span class='line'>table_schema as '数据库',  
</span><span class='line'>table_name as '表名',  
</span><span class='line'>table_rows as '记录数',  
</span><span class='line'>truncate(data_length/1024/1024, 2) as '数据容量(MB)',  
</span><span class='line'>truncate(index_length/1024/1024, 2) as '索引容量(MB)'  
</span><span class='line'>from information_schema.tables  
</span><span class='line'>order by data_length desc, index_length desc; </span></code></pre></td></tr></table></div></figure>


<p>可以查询库里的表名、数据容量和索引容量。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/03/18/corswen-ti/">CORS问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2021-03-18T13:40:00+08:00" pubdate data-updated="true">Mar 18<span>th</span>, 2021</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>动手搞了一下Nginx和Chrome的CORS问题，顺手记录一下一些基本概念。</p>

<p>CORS的本意是限制Http请求中Origin的来源，主要是用于保护浏览器客户端的，可以一定程度上防止浏览器访问页面A时，莫名其妙连去B站资源的情况发生。</p>

<p>原理上，CORS工作时会先发出一个OPTIONS请求，并携带Origin消息头：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OPTIONS /
</span><span class='line'>Host: service.example.com
</span><span class='line'>Origin: http://www.example.com
</span><span class='line'>Access-Control-Request-Method: PUT</span></code></pre></td></tr></table></div></figure>


<p>然后，服务器端如果支持跨域，则会返回Access-Control-Allow-Origin消息头，里面给出允许访问的Origin域名。如果用<code>*</code>，则表示没有任何限制。如果要允许多个域名，则可以使用Nginx中动态变量的方法，这种情况下每次还是只返回一个域名。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>location / {
</span><span class='line'>
</span><span class='line'>                root html;
</span><span class='line'>             if ($request_method = "OPTIONS") {
</span><span class='line'>add_header Access-Control-Allow-Origin *;
</span><span class='line'>                add_header 'Access-Control-Allow-Credentials' 'true';
</span><span class='line'>                add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With';
</span><span class='line'>                add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS';
</span><span class='line'>                add_header 'Access-Control-Max-Age' 10;
</span><span class='line'>                return 204;
</span><span class='line'>             }
</span><span class='line'>
</span><span class='line'>                add_header 'Access-Control-Allow-Credentials' 'true' always;
</span><span class='line'>                add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With' always;
</span><span class='line'>                add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS' always;
</span><span class='line'>                add_header 'Access-Control-Max-Age' 10 always;
</span><span class='line'>                proxy_set_header host $host;
</span><span class='line'>                proxy_set_header X-real-ip $remote_addr;
</span><span class='line'>                proxy_set_header X-forward-for $proxy_add_x_forwarded_for;
</span><span class='line'>                proxy_pass http://127.0.0.1:8080;
</span><span class='line'>        }</span></code></pre></td></tr></table></div></figure>


<p>Nginx的配置需要注意两点：</p>

<ol>
<li>add_header在proxy_pass时默认不会起作用，如果需要起作用，则要加上<code>always</code>参数。</li>
<li>Access-Control-Allow-Origin 要严格的只有1条，不能有多条。</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/02/26/xiong-jie-de-liang-ben-xiao-shuo/">某IT作家的两本小说</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2021-02-26T13:31:00+08:00" pubdate data-updated="true">Feb 26<span>th</span>, 2021</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>图书馆可以采购新书，就买了熊节的『敏捷中国史话』来看了一下。看的过程中，发现作者七年前还写过一本自传类的书籍，也就是「不敢止步」，而史话中比较有意思的内容大都来自不敢止步，于是又去找来不敢止步看。也大致对作者的生平有了更多的了解。</p>

<p>从那本自传小说里，作者说他做性格测验和360调查时，结果都是认为他很有勇气，然而作者并没有意识到自己很有勇气。但从他的所做所为来看，他是很有勇气的。表现在下面几件事情上：</p>

<ul>
<li>勇于退学：在大四时，老师要其补考，他挂科的科目也很多，挂科多本来就是一种勇气的体现，但是他却拒绝了补考的机会并且直接选择了退学。一般人是很难有勇气做出这种半主动退学的决定的。</li>
<li>为了去杭州和处了5年的研究生女朋友分手：虽然彼时两人的方向已出现分歧，01年之后能继续在一起就堪称不易，但因为要去杭州而直接放弃一个女朋友，也是要有点勇气的。</li>
<li>努力找侯捷要求让自己翻译的重构一书出版：大师起初是拒绝的，后来是被打动了。</li>
<li>和结婚几年的中学同学离婚： 把北京和西安合计两套房子都留给了女方，这个真的太有种了。</li>
<li>不要小孩似乎都不需要讨论和下决心的</li>
<li>坦诚真相：把上述事情都写出来，坦然地面对自己、自己的过去、朋友和读者，要做到这个并不容易。</li>
</ul>


<p>至于作者的角色类型，个人认为是一个出色的技术媒体人，另外很适合干有后台的拓荒工作。为实现自己认为正确的事情，可以不计自己的得失，而且勇于投入，即这是一个擅长从1做到100的人才。因为这份真实就值得一读，也值得钦佩。</p>

<p>下面是读书过程中的流水账：</p>

<p>作者2000年开始给私人老板接私活，是用于证券交易所的大屏幕，在屏幕上显示行情信息，需要使用串口程序来控制单片机显示内容。每月800块钱。
因此也荒废学业，到01年大四上的时候，因被要求补考，决定退学。<br/>
之后，01年10月份开始，得到了蒋涛的面试，获得了技术编辑的岗位，开始作为媒体人而工作。<br/>
做了一年半，到03年5月，动身去杭州，加入了石一楹推荐的何晓东的北大青鸟公司开始做开发。在北京杂志社的一年多时间里，翻译了不少书籍，但彼时的英文口语比较烂。谈了一个5年的研究生女友，也同居了，但因离开北京而分手。
在北京，同孟岩等后面的知名编辑同时进入蒋涛门下，蒋涛曾经是雷军副手。联系侯捷，主动要求义务翻译《重构》。</p>

<p>2003年在杭州做了浙江省企业年检的项目。彼时Java 1.5刚面试，项目是用1.3做的。WebWork已经有了，但还不流行。Spring的作者也才展露头角。Oberg彼时受雇于JBoss，Thoughtworks当时还是很高大上的存在，打嘴炮的高手团队。
侯捷还是挺大度的，让熊在译出来的书籍上作为第二译者。2003年8月出版。</p>

<p>04年又干了一年，中间开始偷懒，也和中学同学结了婚，年底返回北京蒋涛处。</p>

<p>05年离开csdn是因为老蒋喜欢用一个贵的人去带十个月薪两千以下的人，因此管理压力很大，有些人会觉得无聊。
05年认识了郭晓和Sidney（一个纽约商人，中国区TW的首任老总）。他们为TW(ThoughtWorks)来中国推展业务，驻地在西安，因为参考了在美国要东西两岸飞。
翻译了ror的书，用了林芷薰的化名。去厦门做了个卖游戏道具的厦门，驻场开发，但是有老外。在班加罗尔的培训绩效评价并不好。</p>

<p>06年在北京有了办公地点，但在北京算是出差。去了几个月墨尔本做selenium的项目，TW的风格就是虎头蛇尾，有点子但是难坚持。之后回北京准备了敏捷的培训课程，去香港用Rails做了一个不成功的项目。但tw招人的素质一直很不错。</p>

<p>07年开始转型做离岸外包，然后又接了巨华的咨询大单，实际上还是巨华的研发领导新官上任三把火。2007年关闭了西安办公室，并且有了移民澳洲的打算。到11年是放弃了澳洲的居民签证，不过还是有很多朋友和前同事在澳大利亚。因为澳大利亚是他们离岸软件的一个很大的客户。</p>

<p>08年主要为巨华服务。TW习惯360度评估，也买车了。2005年就在北京的望京买房了。郭晓在tw的第一个导师是库宁汉姆。08年离婚，西安北京的两套房子都留给了前妻。
巨华是矩阵式的结构，就是资源，有资源的领导，平时都发在项目组合版本里面，然后版本经理和项目组长的意见是决定性的，然后他们是一周有四天加班到11点，周三周六晚上可以不加班啊，周六需要加班的这样子。</p>

<p>09年做澳洲图片项目。通过豆瓣认识了北大女博士梁心作女朋友。他认为项目管理就是控制范围。</p>

<p>10年在巨华变成了所谓的管理者，以及咨询总监，就是管咨询师接巨华这种项目的。然后TW也开始搞995训练新人了，此时在西安Make TW again。</p>

<p>11年的项目就放弃了rails改用java。然后同年接受了head of consulting的任命，咨询和外包服务分开。去成都开分公司，进入14*6的工作节奏。协作好澳洲大客户Suncorp，搞起来了客户关系。
但人其实也受了巨华很大的影响。之后的管理风格很偏巨华。书的末尾写到打算去非洲做TW的医疗项目。</p>

<p>从网上的信息来看，后来因为我也去了非洲乌干达和海地等地区，项目成果没发现。在18年的时候，跳槽去了成都新开的宝尊，也是类似一个分公司的老总。这个公司的特色，我们懂的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2021/02/16/dddde-lan-shu-he-hong-shu/">DDD的蓝书和红书</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2021-02-16T21:37:00+08:00" pubdate data-updated="true">Feb 16<span>th</span>, 2021</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>跟着Vlad的「Unit Testing Principles, Practices, and Patterns」 学习单元测试的原理实践和模式之后，
一路追踪，自然会发现要写好测试自然会要用到Domain-Driven Design的分析和设计方式。因为要写出容易测试代码，
首先需要写出业务上的好代码，而要做到这一点，目前已知的解法殊途同归，就是要运用DDD的方式，解除业务代码对框架和技术细节的依赖，而专注于业务（领域）本身。加上多年以前DHH推荐的5本他膺服的编程书籍中，就有Eric Evans的「Domain-Driven Design」，也就是蓝皮书。</p>

<p>但这本书确实很不好读。中文版的购于去年3月份，反反复复并看不下去，7月份开始看英文版，废了半年的时间，才断断续续终于看完了。蓝皮书确实写的是不容易褪色和随着时间流逝而跌价的书籍，内里的原则和一些很细节的建议应该只要OO继续是编程的主要范式，那么蓝皮书的价值和地位就会持续存在。比如他评价OO把一切都看成对象，就是等于建筑师把一切都看成房间。过于抽象，其实反而失去了运用时的指导意义。为此，开发出了七种武器来分别描述不同的用于处理业务的OO。</p>

<p>而统一语言，则是强调分析人员、设计人员和最终使用人员使用同一种语言来进行沟通，就像厨房、卫生间、客厅等并非只是建筑师的用语。这样可以用一套原则来进行指导和沟通。DDD本身强调独立性的目的，是通过解除对外部的依赖从而达到可以把核心问题暴露出来并予以解决。从而可以让运维逻辑丰富且清晰，将Domain作为软件的核心，而把APP层做薄。沿着这条路前进了多年之后，随着TDD等实践的进一步发展，获得了易测试等突破性的好处。因此，在国外甚至国内部分项目中，都取得了广泛的应用。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2025/04/30/cong-bing-fa-dao-kotlinhe-mo-shi-de-xue-xi/">从并发到Kotlin和模式的学习</a>
      </li>
    
      <li class="post">
        <a href="/blog/2022/04/23/wfh-yi-ge-ban-yue/">WFH一个半月</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/12/30/2021-crvyang-che-cheng-ben-hui-zong/">2021 CRV养车成本汇总</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/10/26/the-kubernetes-book/">The Kubernetes Book</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/10/04/java-8-9-10-in-action/">Java 8 9 10 in action</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/技术'>技术 (96)</a></li><li><a href='/blog/categories/生活'>生活 (54)</a></li><li><a href='/blog/categories/车车'>车车 (40)</a></li><li><a href='/blog/categories/java'>Java (36)</a></li><li><a href='/blog/categories/读书笔记'>读书笔记 (26)</a></li><li><a href='/blog/categories/时评'>时评 (24)</a></li><li><a href='/blog/categories/神器'>神器 (23)</a></li><li><a href='/blog/categories/笔记'>笔记 (21)</a></li><li><a href='/blog/categories/ruby'>Ruby (18)</a></li><li><a href='/blog/categories/spring'>Spring (15)</a></li><li><a href='/blog/categories/项目管理'>项目管理 (14)</a></li><li><a href='/blog/categories/rails'>Rails (13)</a></li><li><a href='/blog/categories/linux'>Linux (12)</a></li><li><a href='/blog/categories/软考'>软考 (8)</a></li><li><a href='/blog/categories/云计算'>云计算 (6)</a></li><li><a href='/blog/categories/crv'>Crv (6)</a></li><li><a href='/blog/categories/nodejs'>Nodejs (6)</a></li><li><a href='/blog/categories/nosql数据库'>Nosql数据库 (5)</a></li><li><a href='/blog/categories/旅游'>旅游 (4)</a></li><li><a href='/blog/categories/管理'>管理 (4)</a></li><li><a href='/blog/categories/装机'>装机 (4)</a></li><li><a href='/blog/categories/heroku'>Heroku (4)</a></li><li><a href='/blog/categories/读书列表'>读书列表 (3)</a></li><li><a href='/blog/categories/git'>Git (3)</a></li><li><a href='/blog/categories/script'>Script (3)</a></li><li><a href='/blog/categories/mac'>Mac (2)</a></li><li><a href='/blog/categories/期刊'>期刊 (2)</a></li><li><a href='/blog/categories/外刊'>外刊 (2)</a></li><li><a href='/blog/categories/java'>Java (36)</a></li><li><a href='/blog/categories/键盘'>键盘 (1)</a></li><li><a href='/blog/categories/测试'>测试 (1)</a></li><li><a href='/blog/categories/安卓'>安卓 (1)</a></li><li><a href='/blog/categories/kotlin'>Kotlin (1)</a></li><li><a href='/blog/categories/区块链'>区块链 (1)</a></li><li><a href='/blog/categories/读书'>读书 (1)</a></li></ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2025 - Hegel 2011 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <a title="Web Statistics" href="http://getclicky.com/66623321"><img alt="Web Statistics" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
  <script src="//static.getclicky.com/js" type="text/javascript"></script>
  <script type="text/javascript">try{ clicky.init(66623321); }catch(e){}</script>
  <noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/66623321ns.gif" /></p></noscript>

</p>

</footer>
  







<script type="text/javascript">
    (function() {
        var twitterWidgets = document.createElement('script');
        twitterWidgets.type = 'text/javascript';
        twitterWidgets.async = true;
        twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
        document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
</script>




</body>
</html>
